{
  "language": "Solidity",
  "sources": {
    "contracts/AutomatedVaultController.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n\r\nimport { ICreditor } from \"./interfaces/ICreditor.sol\";\r\nimport { IDeltaNeutralVault } from \"./interfaces/IDeltaNeutralVault.sol\";\r\n\r\n/// @title AutomatedVaultController - Controller how much investor can invest in the private automated vault\r\ncontract AutomatedVaultController is OwnableUpgradeable {\r\n  // --- Events ---\r\n  event LogSetPrivateVaults(address indexed _caller, IDeltaNeutralVault[] _vaults);\r\n  event LogSetCreditors(address indexed _caller, ICreditor[] _creditors);\r\n\r\n  // --- State Variables ---\r\n  ICreditor[] public creditors;\r\n  IDeltaNeutralVault[] public privateVaults;\r\n  mapping(address => mapping(address => uint256)) public userVaultShares;\r\n\r\n  constructor() initializer {}\r\n\r\n  /// @notice Initialize Automated Vault Controller\r\n  /// @param _creditors list of credit sources\r\n  /// @param _privateVaults list of private automated vaults\r\n  function initialize(ICreditor[] memory _creditors, IDeltaNeutralVault[] memory _privateVaults) external initializer {\r\n    // sanity check\r\n    uint256 _creditorLength = _creditors.length;\r\n    for (uint8 _i = 0; _i < _creditorLength; _i++) {\r\n      _creditors[_i].getUserCredit(address(0));\r\n    }\r\n\r\n    uint256 _privateVaultLength = _privateVaults.length;\r\n    for (uint8 _i = 0; _i < _privateVaultLength; _i++) {\r\n      _privateVaults[_i].shareToValue(1e18);\r\n    }\r\n\r\n    // effect\r\n    OwnableUpgradeable.__Ownable_init();\r\n    creditors = _creditors;\r\n    privateVaults = _privateVaults;\r\n  }\r\n\r\n  /// @notice Get total credit for this user\r\n  /// @param _user address of user.\r\n  /// @return _total user's credit in USD value\r\n  function totalCredit(address _user) public view returns (uint256) {\r\n    uint256 _total;\r\n    uint256 _creditorLength = creditors.length;\r\n    for (uint8 _i = 0; _i < _creditorLength; ) {\r\n      _total = _total + creditors[_i].getUserCredit(_user);\r\n      // uncheck overflow to save gas\r\n      unchecked {\r\n        _i++;\r\n      }\r\n    }\r\n    return _total;\r\n  }\r\n\r\n  /// @notice Get used credit for this user\r\n  /// @param _user address of user.\r\n  /// @return _total user's used credit in USD value from depositing into private automated vaults\r\n  function usedCredit(address _user) public view returns (uint256) {\r\n    uint256 _total;\r\n    uint256 _privateVaultLength = privateVaults.length;\r\n    for (uint8 _i = 0; _i < _privateVaultLength; ) {\r\n      uint256 _share = userVaultShares[_user][address(privateVaults[_i])];\r\n      if (_share != 0) _total += privateVaults[_i].shareToValue(_share);\r\n      // uncheck overflow to save gas\r\n      unchecked {\r\n        _i++;\r\n      }\r\n    }\r\n\r\n    return _total;\r\n  }\r\n\r\n  /// @notice Get availableCredit credit for this user\r\n  /// @param _user address of user.\r\n  /// @return _total remaining credit of this user\r\n  function availableCredit(address _user) public view returns (uint256) {\r\n    uint256 _total = totalCredit(_user);\r\n    uint256 _used = usedCredit(_user);\r\n    return _total > _used ? _total - _used : 0;\r\n  }\r\n\r\n  /// @notice set private automated vaults\r\n  /// @param _newPrivateVaults list of private automated vaults\r\n  function setPrivateVaults(IDeltaNeutralVault[] memory _newPrivateVaults) external onlyOwner {\r\n    // sanity check\r\n    uint256 _newPrivateVaultLength = _newPrivateVaults.length;\r\n    for (uint8 _i = 0; _i < _newPrivateVaultLength; ) {\r\n      _newPrivateVaults[_i].shareToValue(1e18);\r\n      // uncheck overflow to save gas\r\n      unchecked {\r\n        _i++;\r\n      }\r\n    }\r\n\r\n    // effect\r\n    privateVaults = _newPrivateVaults;\r\n\r\n    emit LogSetPrivateVaults(msg.sender, _newPrivateVaults);\r\n  }\r\n\r\n  /// @notice set private automated vaults\r\n  /// @param _newCreditors list of credit sources\r\n  function setCreditors(ICreditor[] memory _newCreditors) external onlyOwner {\r\n    // sanity check\r\n    uint256 _newCreditorLength = _newCreditors.length;\r\n    for (uint8 _i = 0; _i < _newCreditorLength; ) {\r\n      _newCreditors[_i].getUserCredit(address(0));\r\n      // uncheck overflow to save gas\r\n      unchecked {\r\n        _i++;\r\n      }\r\n    }\r\n\r\n    // effect\r\n    creditors = _newCreditors;\r\n\r\n    emit LogSetCreditors(msg.sender, _newCreditors);\r\n  }\r\n\r\n  /// @notice record user's automated vault's share from deposit\r\n  /// @param _user share owner\r\n  /// @param _shareAmount amount of automated vault's share\r\n  function onDeposit(address _user, uint256 _shareAmount) external {\r\n    // expected delta vault to be the caller\r\n    userVaultShares[_user][msg.sender] += _shareAmount;\r\n  }\r\n\r\n  /// @notice update user's automated vault's share from withdrawal\r\n  /// @param _user share owner\r\n  /// @param _shareAmount amount of automated vault's share withdrawn\r\n  function onWithdraw(address _user, uint256 _shareAmount) external {\r\n    userVaultShares[_user][msg.sender] = userVaultShares[_user][msg.sender] <= _shareAmount\r\n      ? 0\r\n      : userVaultShares[_user][msg.sender] - _shareAmount;\r\n  }\r\n\r\n  /// @notice Return share of user of given vault\r\n  /// @param _user share owner\r\n  /// @param _vault delta vault\r\n  function getUserVaultShares(address _user, address _vault) external view returns (uint256) {\r\n    return userVaultShares[_user][_vault];\r\n  }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/interfaces/ICreditor.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface ICreditor {\r\n  function getUserCredit(address _user) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IDeltaNeutralVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface IDeltaNeutralVault {\r\n  function shareToValue(uint256 _shareAmount) external view returns (uint256);\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/xALPACACreditor.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n\r\nimport { IxALPACA } from \"./interfaces/IxALPACA.sol\";\r\nimport { ICreditor } from \"./interfaces/ICreditor.sol\";\r\n\r\n/// @title xALPACACreditor - Assess credit of user per xALPACA that user's holding\r\ncontract xALPACACreditor is OwnableUpgradeable, ICreditor {\r\n  // --- Events ---\r\n  event LogSetValuePerxALPACA(address indexed _caller, uint256 _oldValuePerxALPACA, uint256 _newValuePerxALPACA);\r\n  event LogSetValueSetter(address indexed _caller, address indexed _valueSetter);\r\n\r\n  // --- Errors ---\r\n  error xALPACACreditor_ValueTooHigh();\r\n  error xALPACACreditor_Unauthorize();\r\n\r\n  // --- States ---\r\n  IxALPACA public xALPACA;\r\n  uint256 public valuePerxALPACA;\r\n  address public valueSetter;\r\n\r\n  constructor() initializer {}\r\n\r\n  /// @notice Initialize xALPACACreditor\r\n  /// @param _xALPACA xALPACA.\r\n  /// @param _valuePerxALPACA USD value per 1 xALPACA\r\n  function initialize(IxALPACA _xALPACA, uint256 _valuePerxALPACA) external initializer {\r\n    // sanity check\r\n    _xALPACA.epoch();\r\n\r\n    OwnableUpgradeable.__Ownable_init();\r\n    xALPACA = IxALPACA(_xALPACA);\r\n    valuePerxALPACA = _valuePerxALPACA;\r\n  }\r\n\r\n  /// @notice Get user's credit in USD value\r\n  /// @param _user address of user.\r\n  /// @return user's credit in USD value\r\n  function getUserCredit(address _user) external view returns (uint256) {\r\n    return (xALPACA.balanceOf(_user) * valuePerxALPACA) / 1e18;\r\n  }\r\n\r\n  /// @notice set the value setter\r\n  function setValueSetter(address _newValueSetter) external onlyOwner {\r\n    valueSetter = _newValueSetter;\r\n    emit LogSetValueSetter(msg.sender, _newValueSetter);\r\n  }\r\n\r\n  /// @notice Set the value per xALPACA\r\n  /// @param _newValuePerxALPACA new value to be set.\r\n  function setValuePerxALPACA(uint256 _newValuePerxALPACA) external {\r\n    if (msg.sender != valueSetter) {\r\n      revert xALPACACreditor_Unauthorize();\r\n    }\r\n    if (_newValuePerxALPACA > 1000 * 1e18) {\r\n      revert xALPACACreditor_ValueTooHigh();\r\n    }\r\n\r\n    uint256 _oldValuePerxALPACA = valuePerxALPACA;\r\n    valuePerxALPACA = _newValuePerxALPACA;\r\n\r\n    emit LogSetValuePerxALPACA(msg.sender, _oldValuePerxALPACA, _newValuePerxALPACA);\r\n  }\r\n}\r\n"
    },
    "contracts/interfaces/IxALPACA.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface IxALPACA {\r\n  function balanceOf(address _user) external view returns (uint256);\r\n\r\n  function balanceOfAt(address _user, uint256 _blockNumber) external view returns (uint256);\r\n\r\n  function epoch() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/xALPACAPriceSetter.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n\r\nimport { IxALPACACreditor } from \"./interfaces/IxALPACACreditor.sol\";\r\nimport { ITWAPOracle } from \"./interfaces/ITWAPOracle.sol\";\r\n\r\n/// @title xALPACAPriceSetter - Being setter of xALPACACreditor\r\ncontract xALPACAPriceSetter is OwnableUpgradeable {\r\n  // --- Events ---\r\n  event LogSetValueFromTWAP(address indexed _caller, uint256 _xALPACAValue);\r\n  event LogSetPriceSetter(address indexed _caller, address indexed _priceSetter);\r\n\r\n  // --- Errors ---\r\n  error xALPACAPriceSetter_Unauthorize();\r\n\r\n  // --- States ---\r\n  IxALPACACreditor public xALPACACreditor;\r\n  ITWAPOracle public TWAPOracle;\r\n  address public alpaca;\r\n  address public priceSetter;\r\n  \r\n  /// @notice Initialize xALPACAPriceSetter\r\n  /// @param _xALPACACreditor xALPACreditor\r\n  /// @param _TWAPOracle TWAPOracle\r\n  /// @param _alpaca Contract's address of ALPACA Token\r\n  function initialize(IxALPACACreditor _xALPACACreditor, ITWAPOracle _TWAPOracle, address _alpaca) external initializer {\r\n\r\n    OwnableUpgradeable.__Ownable_init();\r\n    xALPACACreditor = IxALPACACreditor(_xALPACACreditor);\r\n    TWAPOracle = _TWAPOracle;\r\n    alpaca = _alpaca;\r\n  }\r\n\r\n  function setPriceSetter(address _priceSetter) external onlyOwner {\r\n    priceSetter = _priceSetter;\r\n    emit LogSetPriceSetter(msg.sender, _priceSetter);\r\n  }\r\n\r\n  /// @notice Set ALPACA Value (TWAP) as xALPACA Value\r\n  function setValueFromTWAP() external {\r\n    if (msg.sender != priceSetter) {\r\n      revert xALPACAPriceSetter_Unauthorize();\r\n    }\r\n\r\n    uint256 _xALPACAValue = TWAPOracle.getPrice(alpaca);\r\n    xALPACACreditor.setValuePerxALPACA(_xALPACAValue);\r\n\r\n    emit LogSetValueFromTWAP(msg.sender, _xALPACAValue);\r\n  }\r\n\r\n}"
    },
    "contracts/interfaces/IxALPACACreditor.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface IxALPACACreditor {\r\n  function getUserCredit(address _user) external view returns (uint256);\r\n\r\n  function setValuePerxALPACA(uint256 _newValuePerxALPACA) external;\r\n\r\n  function setValueSetter(address _newValueSetter) external;\r\n\r\n  function valuePerxALPACA() external view returns (uint256);\r\n}"
    },
    "contracts/interfaces/ITWAPOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface ITWAPOracle {\r\n  function getPrice(address _tokenAddress) external view returns (uint256);\r\n}"
    },
    "contracts/DeltaNeutralVaultConfig02.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n\r\nimport \"./interfaces/IDeltaNeutralVaultConfig02.sol\";\r\nimport \"./interfaces/IController.sol\";\r\n\r\n/// @title DeltaNeutralVaultConfig02 - A place where you can find all delta neutral vault config\r\n// solhint-disable max-states-count\r\ncontract DeltaNeutralVaultConfig02 is IDeltaNeutralVaultConfig02, OwnableUpgradeable {\r\n  // --- Events ---\r\n  event LogSetParams(\r\n    address indexed _caller,\r\n    address _getWrappedNativeAddr,\r\n    address _getWNativeRelayer,\r\n    address _fairLaunchAddr,\r\n    uint256 _rebalanceFactor,\r\n    uint256 _positionValueTolerance,\r\n    uint256 _debtRatioTolerance\r\n  );\r\n  event LogSetWhitelistedCallers(address indexed _caller, address indexed _address, bool _ok);\r\n  event LogSetWhitelistedRebalancers(address indexed _caller, address indexed _address, bool _ok);\r\n  event LogSetFeeExemptedCallers(address indexed _caller, address indexed _address, bool _ok);\r\n  event LogSetSwapRoute(address indexed _caller, address indexed _swapRouter, address source, address destination);\r\n  event LogSetLeverageLevel(address indexed _caller, uint8 _newLeverageLevel);\r\n  event LogSetAlpacaBountyConfig(address indexed _caller, address _alpacaReinvestTreasury, uint256 _alpacaBountyBps);\r\n  event LogSetAlpacaBeneficiaryConfig(\r\n    address indexed _caller,\r\n    address _alpacaBeneficiary,\r\n    uint256 _alpacaBeneficiaryBps\r\n  );\r\n  event LogSetWhitelistedReinvestors(address indexed _caller, address indexed _address, bool _ok);\r\n  event LogSetValueLimit(address indexed _caller, uint256 _maxVaultPositionValue);\r\n  event LogSetFees(\r\n    address indexed _caller,\r\n    uint256 _depositFeeBps,\r\n    uint256 _withdrawalFeeBps,\r\n    uint256 _managementFeePerSec\r\n  );\r\n  event LogSetFeeTreasury(\r\n    address indexed _caller,\r\n    address _depositFeeTreasury,\r\n    address _withdrawFeeTreasury,\r\n    address _managementFeeTreasury\r\n  );\r\n  event LogSetSwapRouter(address indexed _caller, address _swapRouter);\r\n  event LogSetReinvestPath(address indexed _caller, address[] _reinvestPath);\r\n  event LogSetController(address indexed _caller, address _controller);\r\n\r\n  event LogSetExecutor(\r\n    address indexed _caller,\r\n    address _depositExecutor,\r\n    address _withdrawExecutor,\r\n    address _rebalanceExecutor,\r\n    address _reinvestExecutor\r\n  );\r\n  event LogSetSwapConfig(address indexed _caller, uint256 swapFee, uint256 swapFeeDenom);\r\n  event LogSetStrategies(\r\n    address indexed _caller,\r\n    address partialCloseMinimizeStrategy,\r\n    address stableAddTwoSideStrategy,\r\n    address assetAddTwoSideStrategy\r\n  );\r\n\r\n  // --- Errors ---\r\n  error DeltaNeutralVaultConfig_LeverageLevelTooLow();\r\n  error DeltaNeutralVaultConfig_TooMuchFee(uint256 _depositFeeBps, uint256 _withdrawalFeeBps, uint256 _mangementFeeBps);\r\n  error DeltaNeutralVaultConfig_TooMuchBounty(uint256 _bounty);\r\n  error DeltaNeutralVaultConfig_InvalidSwapRouter();\r\n  error DeltaNeutralVaultConfig_InvalidReinvestPath();\r\n  error DeltaNeutralVaultConfig_InvalidReinvestPathLength();\r\n\r\n  // --- Constants ---\r\n  uint8 private constant MIN_LEVERAGE_LEVEL = 3;\r\n  uint256 private constant MAX_DEPOSIT_FEE_BPS = 1000;\r\n  uint256 private constant MAX_WITHDRAWAL_FEE_BPS = 1000;\r\n  uint256 private constant MAX_MANGEMENT_FEE_PER_SEC = 3170979198;\r\n  uint256 private constant MAX_ALPACA_BOUNTY_BPS = 2500;\r\n  uint256 private constant MAX_ALPACA_BENEFICIARY_BPS = 6000;\r\n\r\n  // --- States ---\r\n  // Configuration for Delta Neutral Vault\r\n  // Address for wrapped native eg WBNB, WETH\r\n  address public override getWrappedNativeAddr;\r\n  // Address for wNtive Relayer\r\n  address public override getWNativeRelayer;\r\n  // FairLaunch contract address\r\n  address public fairLaunchAddr;\r\n\r\n  // The maximum position value in USD that can be held in the vault\r\n  uint256 public maxVaultPositionValue;\r\n  // If debt ratio went above rebalanceFactor, then rebalance\r\n  uint256 public override rebalanceFactor;\r\n  // Tolerance bps that allow margin for misc calculation\r\n  uint256 public override positionValueTolerance;\r\n  // Specific Tolerance bps use for debt ratio check during withdraw\r\n  uint256 public override debtRatioTolerance;\r\n\r\n  // Deposit fee treasury.\r\n  address public depositFeeTreasury;\r\n  // Fee when user deposit to delta neutral vault\r\n  uint256 public override depositFeeBps;\r\n  // Withdrawal fee treasury.\r\n  address public withdrawalFeeTreasury;\r\n  // Fee when user withdraw from delta neutral vault\r\n  uint256 public override withdrawalFeeBps;\r\n  // Management fee treausry.\r\n  address public managementFeeTreasury;\r\n  // Management fee when users is using the vault\r\n  uint256 public override managementFeePerSec;\r\n\r\n  // Targeted leverage level used for underlying positions\r\n  uint8 public override leverageLevel;\r\n\r\n  // ALPACA token\r\n  address public alpacaToken;\r\n  // The router to be used for swaping ALPACA to other assets\r\n  address public getSwapRouter;\r\n  // The path to be used for reinvesting\r\n  address[] public reinvestPath;\r\n\r\n  // Mapping of whitelisted callers\r\n  mapping(address => bool) public whitelistedCallers;\r\n  // Mapping of whitelisted rebalancers\r\n  mapping(address => bool) public whitelistedRebalancers;\r\n\r\n  // list of exempted callers.\r\n  mapping(address => bool) public feeExemptedCallers;\r\n\r\n  // list of reinvestors\r\n  mapping(address => bool) public whitelistedReinvestors;\r\n\r\n  // ALPACA treausry\r\n  address public alpacaReinvestFeeTreasury;\r\n  // ALPACA bounty percentage.\r\n  uint256 public alpacaBountyBps;\r\n  // ALPACA beneficiary. This is the address that will receive portion of the bounty.\r\n  address public alpacaBeneficiary;\r\n  // ALPACA beneficiary percentage.\r\n  uint256 public alpacaBeneficiaryBps;\r\n\r\n  // Automated Vault Controller\r\n  address public override controller;\r\n\r\n  /// Executor\r\n  address public depositExecutor;\r\n  address public withdrawExecutor;\r\n  address public rebalanceExecutor;\r\n  address public reinvestExecutor;\r\n\r\n  /// swap config\r\n  uint256 public swapFee;\r\n  uint256 public swapFeeDenom;\r\n\r\n  /// Strategies\r\n  address public partialCloseMinimizeStrategy;\r\n  address public stableAddTwoSideStrategy;\r\n  address public assetAddTwoSideStrategy;\r\n\r\n  function initialize(\r\n    address _getWrappedNativeAddr,\r\n    address _getWNativeRelayer,\r\n    address _fairLaunchAddr,\r\n    uint256 _rebalanceFactor,\r\n    uint256 _positionValueTolerance,\r\n    uint256 _debtRatioTolerance,\r\n    address _depositFeeTreasury,\r\n    address _managementFeeTreasury,\r\n    address _withdrawFeeTreasury,\r\n    address _alpacaToken\r\n  ) external initializer {\r\n    OwnableUpgradeable.__Ownable_init();\r\n\r\n    alpacaToken = _alpacaToken;\r\n\r\n    setFees(_depositFeeTreasury, 0, _withdrawFeeTreasury, 0, _managementFeeTreasury, 0);\r\n    setParams(\r\n      _getWrappedNativeAddr,\r\n      _getWNativeRelayer,\r\n      _fairLaunchAddr,\r\n      _rebalanceFactor,\r\n      _positionValueTolerance,\r\n      _debtRatioTolerance\r\n    );\r\n  }\r\n\r\n  function setParams(\r\n    address _getWrappedNativeAddr,\r\n    address _getWNativeRelayer,\r\n    address _fairLaunchAddr,\r\n    uint256 _rebalanceFactor,\r\n    uint256 _positionValueTolerance,\r\n    uint256 _debtRatioTolerance\r\n  ) public onlyOwner {\r\n    getWrappedNativeAddr = _getWrappedNativeAddr;\r\n    getWNativeRelayer = _getWNativeRelayer;\r\n    fairLaunchAddr = _fairLaunchAddr;\r\n    rebalanceFactor = _rebalanceFactor;\r\n    positionValueTolerance = _positionValueTolerance;\r\n    debtRatioTolerance = _debtRatioTolerance;\r\n\r\n    emit LogSetParams(\r\n      msg.sender,\r\n      _getWrappedNativeAddr,\r\n      _getWNativeRelayer,\r\n      _fairLaunchAddr,\r\n      _rebalanceFactor,\r\n      _positionValueTolerance,\r\n      _debtRatioTolerance\r\n    );\r\n  }\r\n\r\n  /// @notice Set whitelisted callers.\r\n  /// @dev Must only be called by owner.\r\n  /// @param _callers addresses to be whitelisted.\r\n  /// @param _ok The new ok flag for callers.\r\n  function setWhitelistedCallers(address[] calldata _callers, bool _ok) external onlyOwner {\r\n    for (uint256 _idx = 0; _idx < _callers.length; _idx++) {\r\n      whitelistedCallers[_callers[_idx]] = _ok;\r\n      emit LogSetWhitelistedCallers(msg.sender, _callers[_idx], _ok);\r\n    }\r\n  }\r\n\r\n  /// @notice Set whitelisted rebalancers.\r\n  /// @dev Must only be called by owner.\r\n  /// @param _callers addresses to be whitelisted.\r\n  /// @param _ok The new ok flag for callers.\r\n  function setWhitelistedRebalancer(address[] calldata _callers, bool _ok) external onlyOwner {\r\n    for (uint256 _idx = 0; _idx < _callers.length; _idx++) {\r\n      whitelistedRebalancers[_callers[_idx]] = _ok;\r\n      emit LogSetWhitelistedRebalancers(msg.sender, _callers[_idx], _ok);\r\n    }\r\n  }\r\n\r\n  /// @notice Set whitelisted reinvestors.\r\n  /// @dev Must only be called by owner.\r\n  /// @param _callers addresses to be whitelisted.\r\n  /// @param _ok The new ok flag for callers.\r\n  function setwhitelistedReinvestors(address[] calldata _callers, bool _ok) external onlyOwner {\r\n    for (uint256 _idx = 0; _idx < _callers.length; _idx++) {\r\n      whitelistedReinvestors[_callers[_idx]] = _ok;\r\n      emit LogSetWhitelistedReinvestors(msg.sender, _callers[_idx], _ok);\r\n    }\r\n  }\r\n\r\n  /// @notice Set leverage level.\r\n  /// @dev Must only be called by owner.\r\n  /// @param _newLeverageLevel The new leverage level to be set. Must be >= 3\r\n  function setLeverageLevel(uint8 _newLeverageLevel) external onlyOwner {\r\n    if (_newLeverageLevel < MIN_LEVERAGE_LEVEL) {\r\n      revert DeltaNeutralVaultConfig_LeverageLevelTooLow();\r\n    }\r\n    leverageLevel = _newLeverageLevel;\r\n    emit LogSetLeverageLevel(msg.sender, _newLeverageLevel);\r\n  }\r\n\r\n  /// @notice Set exempted fee callers.\r\n  /// @dev Must only be called by owner.\r\n  /// @param _callers addresses to be exempted.\r\n  /// @param _ok The new ok flag for callers.\r\n  function setFeeExemptedCallers(address[] calldata _callers, bool _ok) external onlyOwner {\r\n    for (uint256 _idx = 0; _idx < _callers.length; _idx++) {\r\n      feeExemptedCallers[_callers[_idx]] = _ok;\r\n      emit LogSetFeeExemptedCallers(msg.sender, _callers[_idx], _ok);\r\n    }\r\n  }\r\n\r\n  /// @notice Set fees.\r\n  /// @dev Must only be called by owner.\r\n  /// @param _newDepositFeeBps Fee when user deposit to delta neutral vault.\r\n  /// @param _newWithdrawalFeeBps Fee when user deposit to delta neutral vault.\r\n  /// @param _newManagementFeePerSec Mangement Fee per second.\r\n  function setFees(\r\n    address _newDepositFeeTreasury,\r\n    uint256 _newDepositFeeBps,\r\n    address _newWithdrawalFeeTreasury,\r\n    uint256 _newWithdrawalFeeBps,\r\n    address _newManagementFeeTreasury,\r\n    uint256 _newManagementFeePerSec\r\n  ) public onlyOwner {\r\n    if (\r\n      _newDepositFeeBps > MAX_DEPOSIT_FEE_BPS ||\r\n      _newWithdrawalFeeBps > MAX_WITHDRAWAL_FEE_BPS ||\r\n      _newManagementFeePerSec > MAX_MANGEMENT_FEE_PER_SEC\r\n    ) {\r\n      revert DeltaNeutralVaultConfig_TooMuchFee(_newDepositFeeBps, _newWithdrawalFeeBps, _newManagementFeePerSec);\r\n    }\r\n\r\n    depositFeeTreasury = _newDepositFeeTreasury;\r\n    depositFeeBps = _newDepositFeeBps;\r\n\r\n    withdrawalFeeTreasury = _newWithdrawalFeeTreasury;\r\n    withdrawalFeeBps = _newWithdrawalFeeBps;\r\n\r\n    managementFeeTreasury = _newManagementFeeTreasury;\r\n    managementFeePerSec = _newManagementFeePerSec;\r\n\r\n    emit LogSetFees(msg.sender, _newDepositFeeBps, _newWithdrawalFeeBps, _newManagementFeePerSec);\r\n    emit LogSetFeeTreasury(msg.sender, _newDepositFeeTreasury, _newWithdrawalFeeTreasury, _newManagementFeeTreasury);\r\n  }\r\n\r\n  /// @notice Set alpacaBountyBps.\r\n  /// @dev Must only be called by owner.\r\n  /// @param _newAlpacaReinvestFeeTreasury The new address to received ALPACA reinvest fee\r\n  /// @param _newAlpacaBountyBps Fee from reinvesting ALPACA to positions.\r\n  function setAlpacaBountyConfig(address _newAlpacaReinvestFeeTreasury, uint256 _newAlpacaBountyBps)\r\n    external\r\n    onlyOwner\r\n  {\r\n    if (_newAlpacaBountyBps > MAX_ALPACA_BOUNTY_BPS) {\r\n      revert DeltaNeutralVaultConfig_TooMuchBounty(_newAlpacaBountyBps);\r\n    }\r\n\r\n    alpacaReinvestFeeTreasury = _newAlpacaReinvestFeeTreasury;\r\n    alpacaBountyBps = _newAlpacaBountyBps;\r\n\r\n    emit LogSetAlpacaBountyConfig(msg.sender, alpacaReinvestFeeTreasury, alpacaBountyBps);\r\n  }\r\n\r\n  /// @notice Set alpacaBeneficiaryBps.\r\n  /// @dev Must only be called by owner.\r\n  /// @param _newAlpacaBeneficiary The new address to received ALPACA reinvest fee\r\n  /// @param _newAlpacaBeneficiaryBps Fee from reinvesting ALPACA to positions.\r\n  function setAlpacaBeneficiaryConfig(address _newAlpacaBeneficiary, uint256 _newAlpacaBeneficiaryBps)\r\n    external\r\n    onlyOwner\r\n  {\r\n    if (_newAlpacaBeneficiaryBps > MAX_ALPACA_BENEFICIARY_BPS) {\r\n      revert DeltaNeutralVaultConfig_TooMuchBounty(_newAlpacaBeneficiaryBps);\r\n    }\r\n\r\n    alpacaBeneficiary = _newAlpacaBeneficiary;\r\n    alpacaBeneficiaryBps = _newAlpacaBeneficiaryBps;\r\n\r\n    emit LogSetAlpacaBeneficiaryConfig(msg.sender, alpacaBeneficiary, alpacaBeneficiaryBps);\r\n  }\r\n\r\n  /// @notice Set position value limit.\r\n  /// @dev Must only be called by owner.\r\n  /// @param _maxVaultPositionValue Maximum vault size position value.\r\n  function setValueLimit(uint256 _maxVaultPositionValue) external onlyOwner {\r\n    maxVaultPositionValue = _maxVaultPositionValue;\r\n    emit LogSetValueLimit(msg.sender, _maxVaultPositionValue);\r\n  }\r\n\r\n  /// @notice Return if vault can accept new position value.\r\n  /// @param _totalPositionValue new vault position value.\r\n  function isVaultSizeAcceptable(uint256 _totalPositionValue) external view returns (bool) {\r\n    if (_totalPositionValue > maxVaultPositionValue) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /// @dev Set the reinvest configuration.\r\n  /// @param _swapRouter - The router address to update.\r\n  function setSwapRouter(address _swapRouter) external onlyOwner {\r\n    if (_swapRouter == address(0)) revert DeltaNeutralVaultConfig_InvalidSwapRouter();\r\n    getSwapRouter = _swapRouter;\r\n    emit LogSetSwapRouter(msg.sender, _swapRouter);\r\n  }\r\n\r\n  /// @dev Set the reinvest path.\r\n  /// @param _reinvestPath - The reinvest path to update.\r\n  function setReinvestPath(address[] calldata _reinvestPath) external onlyOwner {\r\n    if (_reinvestPath.length < 2) revert DeltaNeutralVaultConfig_InvalidReinvestPathLength();\r\n\r\n    if (_reinvestPath[0] != alpacaToken) revert DeltaNeutralVaultConfig_InvalidReinvestPath();\r\n\r\n    reinvestPath = _reinvestPath;\r\n    emit LogSetReinvestPath(msg.sender, _reinvestPath);\r\n  }\r\n\r\n  /// @dev Get the reinvest path.\r\n  function getReinvestPath() external view returns (address[] memory) {\r\n    return reinvestPath;\r\n  }\r\n\r\n  function setController(address _controller) external onlyOwner {\r\n    // sanity check\r\n    IController(_controller).totalCredit(address(0));\r\n\r\n    controller = _controller;\r\n\r\n    emit LogSetController(msg.sender, _controller);\r\n  }\r\n\r\n  function setExecutor(\r\n    address _depositExecutor,\r\n    address _withdrawExecutor,\r\n    address _rebalanceExecutor,\r\n    address _reinvestExecutor\r\n  ) external onlyOwner {\r\n    depositExecutor = _depositExecutor;\r\n    withdrawExecutor = _withdrawExecutor;\r\n    rebalanceExecutor = _rebalanceExecutor;\r\n    reinvestExecutor = _reinvestExecutor;\r\n\r\n    emit LogSetExecutor(msg.sender, _depositExecutor, _withdrawExecutor, _rebalanceExecutor, _reinvestExecutor);\r\n  }\r\n\r\n  /// @notice Return if caller is executor.\r\n  /// @param _caller caller.\r\n  function isExecutor(address _caller) external view returns (bool) {\r\n    return\r\n      _caller == depositExecutor ||\r\n      _caller == withdrawExecutor ||\r\n      _caller == rebalanceExecutor ||\r\n      _caller == reinvestExecutor;\r\n  }\r\n\r\n  function setSwapConfig(uint256 _swapFee, uint256 _swapFeeDenom) external onlyOwner {\r\n    swapFee = _swapFee;\r\n    swapFeeDenom = _swapFeeDenom;\r\n\r\n    emit LogSetSwapConfig(msg.sender, _swapFee, _swapFeeDenom);\r\n  }\r\n\r\n  function setStrategies(\r\n    address _partialCloseMinimizeStrategy,\r\n    address _stableAddTwoSideStrategy,\r\n    address _assetAddTwoSideStrategy\r\n  ) external onlyOwner {\r\n    partialCloseMinimizeStrategy = _partialCloseMinimizeStrategy;\r\n    stableAddTwoSideStrategy = _stableAddTwoSideStrategy;\r\n    assetAddTwoSideStrategy = _assetAddTwoSideStrategy;\r\n\r\n    emit LogSetStrategies(\r\n      msg.sender,\r\n      _partialCloseMinimizeStrategy,\r\n      _stableAddTwoSideStrategy,\r\n      _assetAddTwoSideStrategy\r\n    );\r\n  }\r\n}\r\n"
    },
    "contracts/interfaces/IDeltaNeutralVaultConfig02.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface IDeltaNeutralVaultConfig02 {\r\n  function getWrappedNativeAddr() external view returns (address);\r\n\r\n  function getWNativeRelayer() external view returns (address);\r\n\r\n  function rebalanceFactor() external view returns (uint256);\r\n\r\n  function positionValueTolerance() external view returns (uint256);\r\n\r\n  function debtRatioTolerance() external view returns (uint256);\r\n\r\n  /// @dev Return if the caller is whitelisted.\r\n  function whitelistedCallers(address _caller) external view returns (bool);\r\n\r\n  /// @dev Return if the caller is whitelisted.\r\n  function whitelistedRebalancers(address _caller) external view returns (bool);\r\n\r\n  /// @dev Return if the caller is exempted from fee.\r\n  function feeExemptedCallers(address _caller) external returns (bool);\r\n\r\n  /// @dev Get fairlaunch address.\r\n  function fairLaunchAddr() external view returns (address);\r\n\r\n  /// @dev Return the deposit fee treasury.\r\n  function depositFeeTreasury() external view returns (address);\r\n\r\n  /// @dev Get deposit fee.\r\n  function depositFeeBps() external view returns (uint256);\r\n\r\n  /// @dev Return the withdrawl fee treasury.\r\n  function withdrawalFeeTreasury() external view returns (address);\r\n\r\n  /// @dev Get withdrawal fee.\r\n  function withdrawalFeeBps() external returns (uint256);\r\n\r\n  /// @dev Return management fee treasury\r\n  function managementFeeTreasury() external view returns (address);\r\n\r\n  /// @dev Return management fee per sec.\r\n  function managementFeePerSec() external view returns (uint256);\r\n\r\n  /// @dev Get leverage level.\r\n  function leverageLevel() external view returns (uint8);\r\n\r\n  /// @dev Return if the caller is whitelisted.\r\n  function whitelistedReinvestors(address _caller) external view returns (bool);\r\n\r\n  /// @dev Return ALPACA reinvest fee treasury.\r\n  function alpacaReinvestFeeTreasury() external view returns (address);\r\n\r\n  /// @dev Return alpaca bounty bps.\r\n  function alpacaBountyBps() external view returns (uint256);\r\n\r\n  /// @dev Return ALPACA beneficiary address.\r\n  function alpacaBeneficiary() external view returns (address);\r\n\r\n  /// @dev Return ALPACA beneficiary bps.\r\n  function alpacaBeneficiaryBps() external view returns (uint256);\r\n\r\n  /// @dev Return if delta neutral vault position value acceptable.\r\n  function isVaultSizeAcceptable(uint256 _totalPositionValue) external view returns (bool);\r\n\r\n  /// @dev Return swap router\r\n  function getSwapRouter() external view returns (address);\r\n\r\n  /// @dev Return reinvest path\r\n  function getReinvestPath() external view returns (address[] memory);\r\n\r\n  /// @dev Return controller address\r\n  function controller() external view returns (address);\r\n\r\n  /// @dev Set a new controller\r\n  function setController(address _controller) external;\r\n\r\n  /// @dev Return deposit executor\r\n  function depositExecutor() external view returns (address);\r\n\r\n  /// @dev Return withdraw executor\r\n  function withdrawExecutor() external view returns (address);\r\n\r\n  /// @dev Return rebalance executor\r\n  function rebalanceExecutor() external view returns (address);\r\n\r\n  /// @dev Return reinvest executor\r\n  function reinvestExecutor() external view returns (address);\r\n\r\n  /// @dev Return if caller is executor.\r\n  function isExecutor(address _caller) external view returns (bool);\r\n\r\n  /// @dev Return Partial close minimize strategy address\r\n  function partialCloseMinimizeStrategy() external view returns (address);\r\n\r\n  /// @dev Return Stable add two side strategy address\r\n  function stableAddTwoSideStrategy() external view returns (address);\r\n\r\n  /// @dev Return Asset add two side strategy address\r\n  function assetAddTwoSideStrategy() external view returns (address);\r\n\r\n  /// @dev Return swap fee\r\n  function swapFee() external view returns (uint256);\r\n\r\n  /// @dev Return swap fee denom\r\n  function swapFeeDenom() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface IController {\r\n  function totalCredit(address _user) external view returns (uint256);\r\n\r\n  function usedCredit(address _user) external view returns (uint256);\r\n\r\n  function availableCredit(address _user) external view returns (uint256);\r\n\r\n  function onDeposit(address _user, uint256 _shareAmount) external;\r\n\r\n  function onWithdraw(address _user, uint256 _shareAmount) external;\r\n}\r\n"
    },
    "contracts/DeltaNeutralVault02.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\n\r\nimport \"./interfaces/IDeltaNeutralOracle.sol\";\r\nimport \"./interfaces/IVault.sol\";\r\nimport \"./interfaces/IWorker02.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\nimport \"./interfaces/IWNativeRelayer.sol\";\r\nimport \"./interfaces/IDeltaNeutralVaultConfig02.sol\";\r\nimport \"./interfaces/IFairLaunch.sol\";\r\nimport \"./interfaces/ISwapRouter.sol\";\r\nimport \"./interfaces/IController.sol\";\r\n\r\nimport \"./utils/SafeToken.sol\";\r\nimport \"./utils/FixedPointMathLib.sol\";\r\nimport \"./utils/Math.sol\";\r\nimport \"./utils/FullMath.sol\";\r\n\r\n/// @title DeltaNeutralVault02 is designed to take a long and short position in an asset at the same time\r\n/// to cancel out the effect on the out-standing portfolio when the asset’s price moves.\r\n/// Moreover, DeltaNeutralVault02 support credit-dependent limit access\r\n// solhint-disable max-states-count\r\ncontract DeltaNeutralVault02 is ERC20Upgradeable, ReentrancyGuardUpgradeable, OwnableUpgradeable {\r\n  // --- Libraries ---\r\n  using FixedPointMathLib for uint256;\r\n  using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\r\n  // --- Events ---\r\n  event LogInitializePositions(address indexed _from, uint256 _stableVaultPosId, uint256 _assetVaultPosId);\r\n  event LogDeposit(\r\n    address indexed _from,\r\n    address indexed _shareReceiver,\r\n    uint256 _shares,\r\n    uint256 _stableTokenAmount,\r\n    uint256 _assetTokenAmount\r\n  );\r\n  event LogWithdraw(address indexed _shareOwner, uint256 _minStableTokenAmount, uint256 _minAssetTokenAmount);\r\n  event LogRebalance(uint256 _equityBefore, uint256 _equityAfter);\r\n  event LogReinvest(uint256 _equityBefore, uint256 _equityAfter);\r\n  event LogSetDeltaNeutralOracle(address indexed _caller, address _priceOracle);\r\n  event LogSetDeltaNeutralVaultConfig(address indexed _caller, address _config);\r\n\r\n  // --- Errors ---\r\n  error DeltaNeutralVault_BadReinvestPath();\r\n  error DeltaNeutralVault_BadActionSize();\r\n  error DeltaNeutralVault_Unauthorized(address _caller);\r\n  error DeltaNeutralVault_PositionsAlreadyInitialized();\r\n  error DeltaNeutralVault_PositionsNotInitialized();\r\n  error DeltaNeutralVault_InvalidPositions(address _vault, uint256 _positionId);\r\n  error DeltaNeutralVault_UnsafePositionEquity();\r\n  error DeltaNeutralVault_UnsafePositionValue();\r\n  error DeltaNeutralVault_UnsafeDebtValue();\r\n  error DeltaNeutralVault_UnsafeDebtRatio();\r\n  error DeltaNeutralVault_UnsafeOutstanding(address _token, uint256 _amountBefore, uint256 _amountAfter);\r\n  error DeltaNeutralVault_PositionsIsHealthy();\r\n  error DeltaNeutralVault_InsufficientTokenReceived(address _token, uint256 _requiredAmount, uint256 _receivedAmount);\r\n  error DeltaNeutralVault_InsufficientShareReceived(uint256 _requiredAmount, uint256 _receivedAmount);\r\n  error DeltaNeutralVault_UnTrustedPrice();\r\n  error DeltaNeutralVault_PositionValueExceedLimit();\r\n  error DeltaNeutralVault_WithdrawValueExceedShareValue(uint256 _withdrawValue, uint256 _shareValue);\r\n  error DeltaNeutralVault_IncorrectNativeAmountDeposit();\r\n  error DeltaNeutralVault_InvalidLpToken();\r\n  error DeltaNeutralVault_InvalidInitializedAddress();\r\n  error DeltaNeutralVault_UnsupportedDecimals(uint256 _decimals);\r\n  error DeltaNeutralVault_InvalidShareAmount();\r\n  error DeltaNeutralVault_ExceedCredit();\r\n\r\n  struct Outstanding {\r\n    uint256 stableAmount;\r\n    uint256 assetAmount;\r\n    uint256 nativeAmount;\r\n  }\r\n\r\n  struct PositionInfo {\r\n    uint256 stablePositionEquity;\r\n    uint256 stablePositionDebtValue;\r\n    uint256 stableLpAmount;\r\n    uint256 assetPositionEquity;\r\n    uint256 assetPositionDebtValue;\r\n    uint256 assetLpAmount;\r\n  }\r\n\r\n  // --- Constants ---\r\n  uint64 private constant MAX_BPS = 10000;\r\n\r\n  uint8 private constant ACTION_WORK = 1;\r\n  uint8 private constant ACTION_WRAP = 2;\r\n\r\n  // --- States ---\r\n\r\n  uint256 public stableTo18ConversionFactor;\r\n  uint256 public assetTo18ConversionFactor;\r\n\r\n  address private lpToken;\r\n  address public stableVault;\r\n  address public assetVault;\r\n\r\n  address public stableVaultWorker;\r\n  address public assetVaultWorker;\r\n\r\n  address public stableToken;\r\n  address public assetToken;\r\n  address public alpacaToken;\r\n\r\n  uint256 public stableVaultPosId;\r\n  uint256 public assetVaultPosId;\r\n\r\n  uint256 public lastFeeCollected;\r\n\r\n  IDeltaNeutralOracle public priceOracle;\r\n\r\n  IDeltaNeutralVaultConfig02 public config;\r\n\r\n  // --- Mutable ---\r\n  uint8 private OPENING;\r\n\r\n  /// @dev Require that the caller must be an EOA account if not whitelisted.\r\n  modifier onlyEOAorWhitelisted() {\r\n    if (msg.sender != tx.origin && !config.whitelistedCallers(msg.sender)) {\r\n      revert DeltaNeutralVault_Unauthorized(msg.sender);\r\n    }\r\n    _;\r\n  }\r\n\r\n  /// @dev Require that the caller must be a rebalancer account.\r\n  modifier onlyRebalancers() {\r\n    if (!config.whitelistedRebalancers(msg.sender)) revert DeltaNeutralVault_Unauthorized(msg.sender);\r\n    _;\r\n  }\r\n\r\n  /// @dev Require that the caller must be a reinvestor account.\r\n  modifier onlyReinvestors() {\r\n    if (!config.whitelistedReinvestors(msg.sender)) revert DeltaNeutralVault_Unauthorized(msg.sender);\r\n    _;\r\n  }\r\n\r\n  /// @dev Collect management fee before interactions\r\n  modifier collectFee() {\r\n    _mintFee();\r\n    _;\r\n  }\r\n\r\n  constructor() initializer {}\r\n\r\n  /// @notice Initialize Delta Neutral vault.\r\n  /// @param _name Name.\r\n  /// @param _symbol Symbol.\r\n  /// @param _stableVault Address of stable vault.\r\n  /// @param _assetVault Address of asset vault.\r\n  /// @param _stableVaultWorker Address of stable worker.\r\n  /// @param _stableVaultWorker Address of asset worker.\r\n  /// @param _lpToken Address stable and asset token pair.\r\n  /// @param _alpacaToken Alpaca token address.\r\n  /// @param _priceOracle DeltaNeutralOracle address.\r\n  /// @param _config The address of delta neutral vault config.\r\n  function initialize(\r\n    string calldata _name,\r\n    string calldata _symbol,\r\n    address _stableVault,\r\n    address _assetVault,\r\n    address _stableVaultWorker,\r\n    address _assetVaultWorker,\r\n    address _lpToken,\r\n    address _alpacaToken,\r\n    IDeltaNeutralOracle _priceOracle,\r\n    IDeltaNeutralVaultConfig02 _config\r\n  ) external initializer {\r\n    OwnableUpgradeable.__Ownable_init();\r\n    ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\r\n    ERC20Upgradeable.__ERC20_init(_name, _symbol);\r\n\r\n    stableVault = _stableVault;\r\n    assetVault = _assetVault;\r\n\r\n    stableToken = IVault(_stableVault).token();\r\n    assetToken = IVault(_assetVault).token();\r\n    alpacaToken = _alpacaToken;\r\n\r\n    stableVaultWorker = _stableVaultWorker;\r\n    assetVaultWorker = _assetVaultWorker;\r\n\r\n    lpToken = _lpToken;\r\n\r\n    priceOracle = _priceOracle;\r\n    config = _config;\r\n\r\n    stableTo18ConversionFactor = _to18ConversionFactor(stableToken);\r\n    assetTo18ConversionFactor = _to18ConversionFactor(assetToken);\r\n\r\n    // check if parameters config properly\r\n    if (\r\n      lpToken != address(IWorker(assetVaultWorker).lpToken()) ||\r\n      lpToken != address(IWorker(stableVaultWorker).lpToken())\r\n    ) {\r\n      revert DeltaNeutralVault_InvalidLpToken();\r\n    }\r\n    if (address(alpacaToken) == address(0)) revert DeltaNeutralVault_InvalidInitializedAddress();\r\n    if (address(priceOracle) == address(0)) revert DeltaNeutralVault_InvalidInitializedAddress();\r\n    if (address(config) == address(0)) revert DeltaNeutralVault_InvalidInitializedAddress();\r\n  }\r\n\r\n  /// @notice initialize delta neutral vault positions.\r\n  /// @param _stableTokenAmount Amount of stable token transfer to vault.\r\n  /// @param _assetTokenAmount Amount of asset token transfer to vault.\r\n  /// @param _minShareReceive Minimum share that _shareReceiver must receive.\r\n  /// @param _data The calldata to pass along to the proxy action for more working context.\r\n  function initPositions(\r\n    uint256 _stableTokenAmount,\r\n    uint256 _assetTokenAmount,\r\n    uint256 _minShareReceive,\r\n    bytes calldata _data\r\n  ) external payable onlyOwner {\r\n    if (stableVaultPosId != 0 || assetVaultPosId != 0) {\r\n      revert DeltaNeutralVault_PositionsAlreadyInitialized();\r\n    }\r\n\r\n    OPENING = 1;\r\n    stableVaultPosId = IVault(stableVault).nextPositionID();\r\n    assetVaultPosId = IVault(assetVault).nextPositionID();\r\n    deposit(_stableTokenAmount, _assetTokenAmount, msg.sender, _minShareReceive, _data);\r\n\r\n    OPENING = 0;\r\n\r\n    emit LogInitializePositions(msg.sender, stableVaultPosId, assetVaultPosId);\r\n  }\r\n\r\n  /// @notice Get token from msg.sender.\r\n  /// @param _token token to transfer.\r\n  /// @param _amount amount to transfer.\r\n  function _transferTokenToVault(address _token, uint256 _amount) internal {\r\n    if (_token == config.getWrappedNativeAddr()) {\r\n      if (msg.value != _amount) {\r\n        revert DeltaNeutralVault_IncorrectNativeAmountDeposit();\r\n      }\r\n      IWETH(_token).deposit{ value: _amount }();\r\n    } else {\r\n      IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _amount);\r\n    }\r\n  }\r\n\r\n  /// @notice return token to share owenr.\r\n  /// @param _to receiver address.\r\n  /// @param _token token to transfer.\r\n  /// @param _amount amount to transfer.\r\n  function _transferTokenToShareOwner(\r\n    address _to,\r\n    address _token,\r\n    uint256 _amount\r\n  ) internal {\r\n    if (_token == config.getWrappedNativeAddr()) {\r\n      SafeToken.safeTransferETH(_to, _amount);\r\n    } else {\r\n      IERC20Upgradeable(_token).safeTransfer(_to, _amount);\r\n    }\r\n  }\r\n\r\n  /// @notice minting shares as a form of management fee to teasury account\r\n  function _mintFee() internal {\r\n    _mint(config.managementFeeTreasury(), pendingManagementFee());\r\n    lastFeeCollected = block.timestamp;\r\n  }\r\n\r\n  /// @notice Return amount of share pending for minting as a form of management fee\r\n  function pendingManagementFee() public view returns (uint256) {\r\n    uint256 _secondsFromLastCollection = block.timestamp - lastFeeCollected;\r\n    return (totalSupply() * config.managementFeePerSec() * _secondsFromLastCollection) / 1e18;\r\n  }\r\n\r\n  /// @notice Deposit to delta neutral vault.\r\n  /// @param _stableTokenAmount Amount of stable token transfer to vault.\r\n  /// @param _assetTokenAmount Amount of asset token transfer to vault.\r\n  /// @param _shareReceiver Addresses to be receive share.\r\n  /// @param _minShareReceive Minimum share that _shareReceiver must receive.\r\n  /// @param _data The calldata to pass along to the proxy action for more working context.\r\n  function deposit(\r\n    uint256 _stableTokenAmount,\r\n    uint256 _assetTokenAmount,\r\n    address _shareReceiver,\r\n    uint256 _minShareReceive,\r\n    bytes calldata _data\r\n  ) public payable onlyEOAorWhitelisted collectFee nonReentrant returns (uint256) {\r\n    PositionInfo memory _positionInfoBefore = positionInfo();\r\n    Outstanding memory _outstandingBefore = _outstanding();\r\n    _outstandingBefore.nativeAmount = _outstandingBefore.nativeAmount - msg.value;\r\n    // 1. transfer tokens from user to vault\r\n    _transferTokenToVault(stableToken, _stableTokenAmount);\r\n    _transferTokenToVault(assetToken, _assetTokenAmount);\r\n    {\r\n      // 2. call execute to do more work.\r\n      // Perform the actual work, using a new scope to avoid stack-too-deep errors.\r\n      (uint8[] memory _actions, uint256[] memory _values, bytes[] memory _datas) = abi.decode(\r\n        _data,\r\n        (uint8[], uint256[], bytes[])\r\n      );\r\n      _execute(_actions, _values, _datas);\r\n    }\r\n    return\r\n      _checkAndMint(\r\n        _stableTokenAmount,\r\n        _assetTokenAmount,\r\n        _shareReceiver,\r\n        _minShareReceive,\r\n        _positionInfoBefore,\r\n        _outstandingBefore\r\n      );\r\n  }\r\n\r\n  function _checkAndMint(\r\n    uint256 _stableTokenAmount,\r\n    uint256 _assetTokenAmount,\r\n    address _shareReceiver,\r\n    uint256 _minShareReceive,\r\n    PositionInfo memory _positionInfoBefore,\r\n    Outstanding memory _outstandingBefore\r\n  ) internal returns (uint256) {\r\n    // continued from deposit as we're getting stack too deep\r\n    // 3. mint share for shareReceiver\r\n    PositionInfo memory _positionInfoAfter = positionInfo();\r\n    uint256 _depositValue = _calculateEquityChange(_positionInfoAfter, _positionInfoBefore);\r\n\r\n    // For private vault, deposit value should not exeed credit\r\n    // Check availableCredit from msg.sender since user interact with contract directly\r\n    IController _controller = IController(config.controller());\r\n    if (address(_controller) != address(0) && _depositValue > _controller.availableCredit(msg.sender)) {\r\n      revert DeltaNeutralVault_ExceedCredit();\r\n    }\r\n\r\n    // Calculate share from the value gain against the total equity before execution of actions\r\n    uint256 _sharesToUser = _valueToShare(\r\n      _depositValue,\r\n      _positionInfoBefore.stablePositionEquity + _positionInfoBefore.assetPositionEquity\r\n    );\r\n\r\n    if (_sharesToUser < _minShareReceive) {\r\n      revert DeltaNeutralVault_InsufficientShareReceived(_minShareReceive, _sharesToUser);\r\n    }\r\n    _mint(_shareReceiver, _sharesToUser);\r\n\r\n    // 4. sanity check\r\n    _depositHealthCheck(_depositValue, _positionInfoBefore, _positionInfoAfter);\r\n    _outstandingCheck(_outstandingBefore, _outstanding());\r\n\r\n    // Deduct credit from msg.sender regardless of the _shareReceiver.\r\n    if (address(_controller) != address(0)) _controller.onDeposit(msg.sender, _sharesToUser);\r\n\r\n    emit LogDeposit(msg.sender, _shareReceiver, _sharesToUser, _stableTokenAmount, _assetTokenAmount);\r\n    return _sharesToUser;\r\n  }\r\n\r\n  /// @notice Withdraw from delta neutral vault.\r\n  /// @param _shareAmount Amount of share to withdraw from vault.\r\n  /// @param _minStableTokenAmount Minimum stable token shareOwner expect to receive.\r\n  /// @param _minAssetTokenAmount Minimum asset token shareOwner expect to receive.\r\n  /// @param _data The calldata to pass along to the proxy action for more working context.\r\n  function withdraw(\r\n    uint256 _shareAmount,\r\n    uint256 _minStableTokenAmount,\r\n    uint256 _minAssetTokenAmount,\r\n    bytes calldata _data\r\n  ) external onlyEOAorWhitelisted collectFee nonReentrant returns (uint256) {\r\n    if (_shareAmount == 0) revert DeltaNeutralVault_InvalidShareAmount();\r\n\r\n    PositionInfo memory _positionInfoBefore = positionInfo();\r\n    Outstanding memory _outstandingBefore = _outstanding();\r\n\r\n    uint256 _withdrawalFeeBps = config.feeExemptedCallers(msg.sender) ? 0 : config.withdrawalFeeBps();\r\n    uint256 _shareToWithdraw = ((MAX_BPS - _withdrawalFeeBps) * _shareAmount) / MAX_BPS;\r\n    uint256 _withdrawShareValue = shareToValue(_shareToWithdraw);\r\n\r\n    // burn shares from share owner\r\n    _burn(msg.sender, _shareAmount);\r\n\r\n    // mint shares equal to withdrawal fee to treasury.\r\n    _mint(config.withdrawalFeeTreasury(), _shareAmount - _shareToWithdraw);\r\n\r\n    {\r\n      (uint8[] memory actions, uint256[] memory values, bytes[] memory _datas) = abi.decode(\r\n        _data,\r\n        (uint8[], uint256[], bytes[])\r\n      );\r\n      _execute(actions, values, _datas);\r\n    }\r\n\r\n    return\r\n      _checkAndTransfer(\r\n        _shareAmount,\r\n        _minStableTokenAmount,\r\n        _minAssetTokenAmount,\r\n        _withdrawShareValue,\r\n        _positionInfoBefore,\r\n        _outstandingBefore\r\n      );\r\n  }\r\n\r\n  function _checkAndTransfer(\r\n    uint256 _shareAmount,\r\n    uint256 _minStableTokenAmount,\r\n    uint256 _minAssetTokenAmount,\r\n    uint256 _withdrawShareValue,\r\n    PositionInfo memory _positionInfoBefore,\r\n    Outstanding memory _outstandingBefore\r\n  ) internal returns (uint256) {\r\n    PositionInfo memory _positionInfoAfter = positionInfo();\r\n    Outstanding memory _outstandingAfter = _outstanding();\r\n\r\n    // transfer funds back to shareOwner\r\n    uint256 _stableTokenBack = stableToken == config.getWrappedNativeAddr()\r\n      ? _outstandingAfter.nativeAmount - _outstandingBefore.nativeAmount\r\n      : _outstandingAfter.stableAmount - _outstandingBefore.stableAmount;\r\n    uint256 _assetTokenBack = assetToken == config.getWrappedNativeAddr()\r\n      ? _outstandingAfter.nativeAmount - _outstandingBefore.nativeAmount\r\n      : _outstandingAfter.assetAmount - _outstandingBefore.assetAmount;\r\n\r\n    if (_stableTokenBack < _minStableTokenAmount) {\r\n      revert DeltaNeutralVault_InsufficientTokenReceived(stableToken, _minStableTokenAmount, _stableTokenBack);\r\n    }\r\n    if (_assetTokenBack < _minAssetTokenAmount) {\r\n      revert DeltaNeutralVault_InsufficientTokenReceived(assetToken, _minAssetTokenAmount, _assetTokenBack);\r\n    }\r\n\r\n    uint256 _withdrawValue = _calculateEquityChange(_positionInfoBefore, _positionInfoAfter);\r\n\r\n    if (_withdrawShareValue < _withdrawValue) {\r\n      revert DeltaNeutralVault_WithdrawValueExceedShareValue(_withdrawValue, _withdrawShareValue);\r\n    }\r\n\r\n    // sanity check\r\n    _withdrawHealthCheck(_withdrawShareValue, _positionInfoBefore, _positionInfoAfter);\r\n    _outstandingCheck(_outstandingBefore, _outstandingAfter);\r\n\r\n    _transferTokenToShareOwner(msg.sender, stableToken, _stableTokenBack);\r\n    _transferTokenToShareOwner(msg.sender, assetToken, _assetTokenBack);\r\n\r\n    // on withdraw increase credit to tx.origin since user can withdraw from DN Gateway -> DN Vault\r\n    IController _controller = IController(config.controller());\r\n    if (address(_controller) != address(0)) _controller.onWithdraw(tx.origin, _shareAmount);\r\n\r\n    emit LogWithdraw(msg.sender, _stableTokenBack, _assetTokenBack);\r\n\r\n    return _withdrawValue;\r\n  }\r\n\r\n  /// @notice Rebalance stable and asset positions.\r\n  /// @param _actions List of actions to execute.\r\n  /// @param _values Native token amount.\r\n  /// @param _datas The calldata to pass along for more working context.\r\n  function rebalance(\r\n    uint8[] memory _actions,\r\n    uint256[] memory _values,\r\n    bytes[] memory _datas\r\n  ) external onlyRebalancers collectFee {\r\n    PositionInfo memory _positionInfoBefore = positionInfo();\r\n    Outstanding memory _outstandingBefore = _outstanding();\r\n    uint256 _stablePositionValue = _positionInfoBefore.stablePositionEquity +\r\n      _positionInfoBefore.stablePositionDebtValue;\r\n    uint256 _assetPositionValue = _positionInfoBefore.assetPositionEquity + _positionInfoBefore.assetPositionDebtValue;\r\n    uint256 _equityBefore = _positionInfoBefore.stablePositionEquity + _positionInfoBefore.assetPositionEquity;\r\n    uint256 _rebalanceFactor = config.rebalanceFactor(); // bps\r\n\r\n    // 1. check if positions need rebalance\r\n    if (\r\n      _stablePositionValue * _rebalanceFactor >= _positionInfoBefore.stablePositionDebtValue * MAX_BPS &&\r\n      _assetPositionValue * _rebalanceFactor >= _positionInfoBefore.assetPositionDebtValue * MAX_BPS\r\n    ) {\r\n      revert DeltaNeutralVault_PositionsIsHealthy();\r\n    }\r\n\r\n    // 2. execute rebalance\r\n    {\r\n      _execute(_actions, _values, _datas);\r\n    }\r\n\r\n    // 3. sanity check\r\n    // check if position in a healthy state after rebalancing\r\n    uint256 _equityAfter = totalEquityValue();\r\n    if (!Math.almostEqual(_equityAfter, _equityBefore, config.positionValueTolerance())) {\r\n      revert DeltaNeutralVault_UnsafePositionValue();\r\n    }\r\n    _outstandingCheck(_outstandingBefore, _outstanding());\r\n\r\n    emit LogRebalance(_equityBefore, _equityAfter);\r\n  }\r\n\r\n  /// @notice Reinvest fund to stable and asset positions.\r\n  /// @param _actions List of actions to execute.\r\n  /// @param _values Native token amount.\r\n  /// @param _datas The calldata to pass along for more working context.\r\n  /// @param _minTokenReceive Minimum token received when swap reward.\r\n  function reinvest(\r\n    uint8[] memory _actions,\r\n    uint256[] memory _values,\r\n    bytes[] memory _datas,\r\n    uint256 _minTokenReceive\r\n  ) external onlyReinvestors {\r\n    address[] memory reinvestPath = config.getReinvestPath();\r\n    uint256 _alpacaBountyBps = config.alpacaBountyBps();\r\n    uint256 _alpacaBeneficiaryBps = config.alpacaBeneficiaryBps();\r\n\r\n    if (reinvestPath.length == 0) {\r\n      revert DeltaNeutralVault_BadReinvestPath();\r\n    }\r\n\r\n    // 1.  claim reward from fairlaunch\r\n    uint256 _equityBefore = totalEquityValue();\r\n\r\n    address _fairLaunchAddress = config.fairLaunchAddr();\r\n    IFairLaunch(_fairLaunchAddress).harvest(IVault(stableVault).fairLaunchPoolId());\r\n    IFairLaunch(_fairLaunchAddress).harvest(IVault(assetVault).fairLaunchPoolId());\r\n    uint256 _alpacaAmount = IERC20Upgradeable(alpacaToken).balanceOf(address(this));\r\n\r\n    // 2. collect alpaca bounty & distribute to ALPACA beneficiary\r\n    uint256 _bounty = (_alpacaBountyBps * _alpacaAmount) / MAX_BPS;\r\n    uint256 _beneficiaryShare = (_bounty * _alpacaBeneficiaryBps) / MAX_BPS;\r\n    if (_beneficiaryShare > 0)\r\n      IERC20Upgradeable(alpacaToken).safeTransfer(config.alpacaBeneficiary(), _beneficiaryShare);\r\n    IERC20Upgradeable(alpacaToken).safeTransfer(config.alpacaReinvestFeeTreasury(), _bounty - _beneficiaryShare);\r\n\r\n    // 3. swap alpaca\r\n    uint256 _rewardAmount = _alpacaAmount - _bounty;\r\n    ISwapRouter _router = ISwapRouter(config.getSwapRouter());\r\n    IERC20Upgradeable(alpacaToken).approve(address(_router), _rewardAmount);\r\n    _router.swapExactTokensForTokens(_rewardAmount, _minTokenReceive, reinvestPath, address(this), block.timestamp);\r\n\r\n    // 4. execute reinvest\r\n    {\r\n      _execute(_actions, _values, _datas);\r\n    }\r\n\r\n    // 5. sanity check\r\n    uint256 _equityAfter = totalEquityValue();\r\n    if (_equityAfter <= _equityBefore) {\r\n      revert DeltaNeutralVault_UnsafePositionEquity();\r\n    }\r\n\r\n    emit LogReinvest(_equityBefore, _equityAfter);\r\n  }\r\n\r\n  /// @notice check if position equity and debt are healthy after deposit. LEVERAGE_LEVEL must be >= 3\r\n  /// @param _depositValue deposit value in usd.\r\n  /// @param _positionInfoBefore position equity and debt before deposit.\r\n  /// @param _positionInfoAfter position equity and debt after deposit.\r\n  function _depositHealthCheck(\r\n    uint256 _depositValue,\r\n    PositionInfo memory _positionInfoBefore,\r\n    PositionInfo memory _positionInfoAfter\r\n  ) internal view {\r\n    uint256 _toleranceBps = config.positionValueTolerance();\r\n    uint8 _leverageLevel = config.leverageLevel();\r\n\r\n    uint256 _positionValueAfter = _positionInfoAfter.stablePositionEquity +\r\n      _positionInfoAfter.stablePositionDebtValue +\r\n      _positionInfoAfter.assetPositionEquity +\r\n      _positionInfoAfter.assetPositionDebtValue;\r\n\r\n    // 1. check if vault accept new total position value\r\n    if (!config.isVaultSizeAcceptable(_positionValueAfter)) {\r\n      revert DeltaNeutralVault_PositionValueExceedLimit();\r\n    }\r\n\r\n    // 2. check position value\r\n    // The equity allocation of long side should be equal to _depositValue * (_leverageLevel - 2) / ((2*_leverageLevel) - 2)\r\n    uint256 _expectedStableEqChange = (_depositValue * (_leverageLevel - 2)) / ((2 * _leverageLevel) - 2);\r\n    // The equity allocation of short side should be equal to _depositValue * _leverageLevel / ((2*_leverageLevel) - 2)\r\n    uint256 _expectedAssetEqChange = (_depositValue * _leverageLevel) / ((2 * _leverageLevel) - 2);\r\n\r\n    uint256 _actualStableDebtChange = _positionInfoAfter.stablePositionDebtValue -\r\n      _positionInfoBefore.stablePositionDebtValue;\r\n    uint256 _actualAssetDebtChange = _positionInfoAfter.assetPositionDebtValue -\r\n      _positionInfoBefore.assetPositionDebtValue;\r\n\r\n    uint256 _actualStableEqChange = _lpToValue(_positionInfoAfter.stableLpAmount - _positionInfoBefore.stableLpAmount) -\r\n      _actualStableDebtChange;\r\n    uint256 _actualAssetEqChange = _lpToValue(_positionInfoAfter.assetLpAmount - _positionInfoBefore.assetLpAmount) -\r\n      _actualAssetDebtChange;\r\n\r\n    if (\r\n      !Math.almostEqual(_actualStableEqChange, _expectedStableEqChange, _toleranceBps) ||\r\n      !Math.almostEqual(_actualAssetEqChange, _expectedAssetEqChange, _toleranceBps)\r\n    ) {\r\n      revert DeltaNeutralVault_UnsafePositionEquity();\r\n    }\r\n\r\n    // 3. check Debt value\r\n    // The debt allocation of long side should be equal to _expectedStableEqChange * (_leverageLevel - 1)\r\n    uint256 _expectedStableDebtChange = (_expectedStableEqChange * (_leverageLevel - 1));\r\n    // The debt allocation of short side should be equal to _expectedAssetEqChange * (_leverageLevel - 1)\r\n    uint256 _expectedAssetDebtChange = (_expectedAssetEqChange * (_leverageLevel - 1));\r\n\r\n    if (\r\n      !Math.almostEqual(_actualStableDebtChange, _expectedStableDebtChange, _toleranceBps) ||\r\n      !Math.almostEqual(_actualAssetDebtChange, _expectedAssetDebtChange, _toleranceBps)\r\n    ) {\r\n      revert DeltaNeutralVault_UnsafeDebtValue();\r\n    }\r\n  }\r\n\r\n  /// @notice Check if position equity and debt ratio are healthy after withdraw.\r\n  /// @param _withdrawValue Withdraw value in usd.\r\n  /// @param _positionInfoBefore Position equity and debt before deposit.\r\n  /// @param _positionInfoAfter Position equity and debt after deposit.\r\n  function _withdrawHealthCheck(\r\n    uint256 _withdrawValue,\r\n    PositionInfo memory _positionInfoBefore,\r\n    PositionInfo memory _positionInfoAfter\r\n  ) internal view {\r\n    uint256 _positionValueTolerance = config.positionValueTolerance();\r\n    uint256 _debtRationTolerance = config.debtRatioTolerance();\r\n\r\n    uint256 _totalEquityBefore = _positionInfoBefore.stablePositionEquity + _positionInfoBefore.assetPositionEquity;\r\n    uint256 _stableLpWithdrawValue = _lpToValue(_positionInfoBefore.stableLpAmount - _positionInfoAfter.stableLpAmount);\r\n\r\n    // This will force the equity loss in stable vault stay within the expectation\r\n    // Given that the expectation is equity loss in stable vault will not alter the stable equity to total equity ratio\r\n    // _stableExpectedWithdrawValue = _withdrawValue * _positionInfoBefore.stablePositionEquity / _totalEquityBefore\r\n    // _stableActualWithdrawValue should be almost equal to _stableExpectedWithdrawValue\r\n    if (\r\n      !Math.almostEqual(\r\n        (_stableLpWithdrawValue -\r\n          (_positionInfoBefore.stablePositionDebtValue - _positionInfoAfter.stablePositionDebtValue)) *\r\n          _totalEquityBefore,\r\n        _withdrawValue * _positionInfoBefore.stablePositionEquity,\r\n        _positionValueTolerance\r\n      )\r\n    ) {\r\n      revert DeltaNeutralVault_UnsafePositionValue();\r\n    }\r\n\r\n    uint256 _assetLpWithdrawValue = _lpToValue(_positionInfoBefore.assetLpAmount - _positionInfoAfter.assetLpAmount);\r\n\r\n    // This will force the equity loss in asset vault stay within the expectation\r\n    // Given that the expectation is equity loss in asset vault will not alter the asset equity to total equity ratio\r\n    // _assetExpectedWithdrawValue = _withdrawValue * _positionInfoBefore.assetPositionEquity / _totalEquityBefore\r\n    // _assetActualWithdrawValue should be almost equal to _assetExpectedWithdrawValue\r\n    if (\r\n      !Math.almostEqual(\r\n        (_assetLpWithdrawValue -\r\n          (_positionInfoBefore.assetPositionDebtValue - _positionInfoAfter.assetPositionDebtValue)) *\r\n          _totalEquityBefore,\r\n        _withdrawValue * _positionInfoBefore.assetPositionEquity,\r\n        _positionValueTolerance\r\n      )\r\n    ) {\r\n      revert DeltaNeutralVault_UnsafePositionValue();\r\n    }\r\n\r\n    // // debt ratio check to prevent closing all out the debt but the equity stay healthy\r\n    uint256 _totalStablePositionBefore = _positionInfoBefore.stablePositionEquity +\r\n      _positionInfoBefore.stablePositionDebtValue;\r\n    uint256 _totalStablePositionAfter = _positionInfoAfter.stablePositionEquity +\r\n      _positionInfoAfter.stablePositionDebtValue;\r\n    // debt ratio = debt / position\r\n    // debt after / position after ~= debt b4 / position b4\r\n    // position b4 * debt after = position after * debt b4\r\n    if (\r\n      !Math.almostEqual(\r\n        _totalStablePositionBefore * _positionInfoAfter.stablePositionDebtValue,\r\n        _totalStablePositionAfter * _positionInfoBefore.stablePositionDebtValue,\r\n        _debtRationTolerance\r\n      )\r\n    ) {\r\n      revert DeltaNeutralVault_UnsafeDebtRatio();\r\n    }\r\n\r\n    uint256 _totalassetPositionBefore = _positionInfoBefore.assetPositionEquity +\r\n      _positionInfoBefore.assetPositionDebtValue;\r\n    uint256 _totalassetPositionAfter = _positionInfoAfter.assetPositionEquity +\r\n      _positionInfoAfter.assetPositionDebtValue;\r\n\r\n    if (\r\n      !Math.almostEqual(\r\n        _totalassetPositionBefore * _positionInfoAfter.assetPositionDebtValue,\r\n        _totalassetPositionAfter * _positionInfoBefore.assetPositionDebtValue,\r\n        _debtRationTolerance\r\n      )\r\n    ) {\r\n      revert DeltaNeutralVault_UnsafeDebtRatio();\r\n    }\r\n  }\r\n\r\n  /// @notice Compare Delta neutral vault tokens' balance before and afrer.\r\n  /// @param _outstandingBefore Tokens' balance before.\r\n  /// @param _outstandingAfter Tokens' balance after.\r\n  function _outstandingCheck(Outstanding memory _outstandingBefore, Outstanding memory _outstandingAfter)\r\n    internal\r\n    view\r\n  {\r\n    if (_outstandingAfter.stableAmount < _outstandingBefore.stableAmount) {\r\n      revert DeltaNeutralVault_UnsafeOutstanding(\r\n        stableToken,\r\n        _outstandingBefore.stableAmount,\r\n        _outstandingAfter.stableAmount\r\n      );\r\n    }\r\n    if (_outstandingAfter.assetAmount < _outstandingBefore.assetAmount) {\r\n      revert DeltaNeutralVault_UnsafeOutstanding(\r\n        assetToken,\r\n        _outstandingBefore.assetAmount,\r\n        _outstandingAfter.assetAmount\r\n      );\r\n    }\r\n    if (_outstandingAfter.nativeAmount < _outstandingBefore.nativeAmount) {\r\n      revert DeltaNeutralVault_UnsafeOutstanding(\r\n        address(0),\r\n        _outstandingBefore.nativeAmount,\r\n        _outstandingAfter.nativeAmount\r\n      );\r\n    }\r\n  }\r\n\r\n  /// @notice Return stable token, asset token and native token balance.\r\n  function _outstanding() internal view returns (Outstanding memory) {\r\n    return\r\n      Outstanding({\r\n        stableAmount: IERC20Upgradeable(stableToken).balanceOf(address(this)),\r\n        assetAmount: IERC20Upgradeable(assetToken).balanceOf(address(this)),\r\n        nativeAmount: address(this).balance\r\n      });\r\n  }\r\n\r\n  /// @notice Return equity and debt value in usd of stable and asset positions.\r\n  function positionInfo() public view returns (PositionInfo memory) {\r\n    uint256 _stableLpAmount = IWorker02(stableVaultWorker).totalLpBalance();\r\n    uint256 _assetLpAmount = IWorker02(assetVaultWorker).totalLpBalance();\r\n    uint256 _stablePositionValue = _lpToValue(_stableLpAmount);\r\n    uint256 _assetPositionValue = _lpToValue(_assetLpAmount);\r\n    uint256 _stableDebtValue = _positionDebtValue(stableVault, stableVaultPosId, stableTo18ConversionFactor);\r\n    uint256 _assetDebtValue = _positionDebtValue(assetVault, assetVaultPosId, assetTo18ConversionFactor);\r\n\r\n    return\r\n      PositionInfo({\r\n        stablePositionEquity: _stablePositionValue > _stableDebtValue ? _stablePositionValue - _stableDebtValue : 0,\r\n        stablePositionDebtValue: _stableDebtValue,\r\n        stableLpAmount: _stableLpAmount,\r\n        assetPositionEquity: _assetPositionValue > _assetDebtValue ? _assetPositionValue - _assetDebtValue : 0,\r\n        assetPositionDebtValue: _assetDebtValue,\r\n        assetLpAmount: _assetLpAmount\r\n      });\r\n  }\r\n\r\n  /// @notice Return the value of share from the given share amount.\r\n  /// @param _shareAmount Amount of share.\r\n  function shareToValue(uint256 _shareAmount) public view returns (uint256) {\r\n    // From internal call + pendingManagementFee should be 0 as it was collected\r\n    // at the beginning of the external contract call\r\n    // For external call, to calculate shareToValue, pending fee shall be accounted\r\n    uint256 _shareSupply = totalSupply() + pendingManagementFee();\r\n    if (_shareSupply == 0) return _shareAmount;\r\n    return FullMath.mulDiv(_shareAmount, totalEquityValue(), _shareSupply);\r\n  }\r\n\r\n  /// @notice Return the amount of share from the given value.\r\n  /// @param _value value in usd.\r\n  function valueToShare(uint256 _value) external view returns (uint256) {\r\n    return _valueToShare(_value, totalEquityValue());\r\n  }\r\n\r\n  /// @notice Return equity value of delta neutral position.\r\n  function totalEquityValue() public view returns (uint256) {\r\n    uint256 _totalPositionValue = _lpToValue(\r\n      IWorker02(stableVaultWorker).totalLpBalance() + IWorker02(assetVaultWorker).totalLpBalance()\r\n    );\r\n    uint256 _totalDebtValue = _positionDebtValue(stableVault, stableVaultPosId, stableTo18ConversionFactor) +\r\n      _positionDebtValue(assetVault, assetVaultPosId, assetTo18ConversionFactor);\r\n    if (_totalPositionValue < _totalDebtValue) {\r\n      return 0;\r\n    }\r\n    return _totalPositionValue - _totalDebtValue;\r\n  }\r\n\r\n  /// @notice Set new DeltaNeutralOracle.\r\n  /// @param _newPriceOracle New deltaNeutralOracle address.\r\n  function setDeltaNeutralOracle(IDeltaNeutralOracle _newPriceOracle) external onlyOwner {\r\n    // sanity call\r\n    _newPriceOracle.getTokenPrice(stableToken);\r\n    _newPriceOracle.lpToDollar(1e18, lpToken);\r\n\r\n    priceOracle = _newPriceOracle;\r\n    emit LogSetDeltaNeutralOracle(msg.sender, address(_newPriceOracle));\r\n  }\r\n\r\n  /// @notice Set new DeltaNeutralVaultConfig.\r\n  /// @param _newVaultConfig New deltaNeutralOracle address.\r\n  function setDeltaNeutralVaultConfig(IDeltaNeutralVaultConfig02 _newVaultConfig) external onlyOwner {\r\n    // sanity call\r\n    _newVaultConfig.positionValueTolerance();\r\n\r\n    config = _newVaultConfig;\r\n    emit LogSetDeltaNeutralVaultConfig(msg.sender, address(_newVaultConfig));\r\n  }\r\n\r\n  /// @notice Return position debt + pending interest value.\r\n  /// @param _vault Vault addrss.\r\n  /// @param _posId Position id.\r\n  function _positionDebtValue(\r\n    address _vault,\r\n    uint256 _posId,\r\n    uint256 _18ConversionFactor\r\n  ) internal view returns (uint256) {\r\n    (, , uint256 _positionDebtShare) = IVault(_vault).positions(_posId);\r\n    address _token = IVault(_vault).token();\r\n    uint256 _vaultDebtShare = IVault(_vault).vaultDebtShare();\r\n    if (_vaultDebtShare == 0) {\r\n      return (_positionDebtShare * _18ConversionFactor).mulWadDown(_getTokenPrice(_token));\r\n    }\r\n    uint256 _vaultDebtValue = IVault(_vault).vaultDebtVal() + IVault(_vault).pendingInterest(0);\r\n    uint256 _debtAmount = FullMath.mulDiv(_positionDebtShare, _vaultDebtValue, _vaultDebtShare);\r\n    return (_debtAmount * _18ConversionFactor).mulWadDown(_getTokenPrice(_token));\r\n  }\r\n\r\n  /// @notice Return value of given lp amount.\r\n  /// @param _lpAmount Amount of lp.\r\n  function _lpToValue(uint256 _lpAmount) internal view returns (uint256) {\r\n    (uint256 _lpValue, uint256 _lastUpdated) = priceOracle.lpToDollar(_lpAmount, lpToken);\r\n    if (block.timestamp - _lastUpdated > 86400) revert DeltaNeutralVault_UnTrustedPrice();\r\n    return _lpValue;\r\n  }\r\n\r\n  /// @notice Return equity change between two position\r\n  /// @param _greaterPosition Position information that's expected to have higer value\r\n  /// @param _lesserPosition Position information that's expected to have lower value\r\n  function _calculateEquityChange(PositionInfo memory _greaterPosition, PositionInfo memory _lesserPosition)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    uint256 _lpChange = (_greaterPosition.stableLpAmount + _greaterPosition.assetLpAmount) -\r\n      (_lesserPosition.stableLpAmount + _lesserPosition.assetLpAmount);\r\n\r\n    uint256 _debtChange = (_greaterPosition.stablePositionDebtValue + _greaterPosition.assetPositionDebtValue) -\r\n      (_lesserPosition.stablePositionDebtValue + _lesserPosition.assetPositionDebtValue);\r\n\r\n    return _lpToValue(_lpChange) - _debtChange;\r\n  }\r\n\r\n  /// @notice Proxy function for calling internal action.\r\n  /// @param _actions List of actions to execute.\r\n  /// @param _values Native token amount.\r\n  /// @param _datas The calldata to pass along for more working context.\r\n  function _execute(\r\n    uint8[] memory _actions,\r\n    uint256[] memory _values,\r\n    bytes[] memory _datas\r\n  ) internal {\r\n    if (_actions.length != _values.length || _actions.length != _datas.length) revert DeltaNeutralVault_BadActionSize();\r\n\r\n    for (uint256 i = 0; i < _actions.length; i++) {\r\n      uint8 _action = _actions[i];\r\n      if (_action == ACTION_WORK) {\r\n        _doWork(_datas[i]);\r\n      }\r\n      if (_action == ACTION_WRAP) {\r\n        IWETH(config.getWrappedNativeAddr()).deposit{ value: _values[i] }();\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice interact with delta neutral position.\r\n  /// @param _data The calldata to pass along to the vault for more working context.\r\n  function _doWork(bytes memory _data) internal {\r\n    if (stableVaultPosId == 0 || assetVaultPosId == 0) {\r\n      revert DeltaNeutralVault_PositionsNotInitialized();\r\n    }\r\n\r\n    // 1. Decode data\r\n    (\r\n      address payable _vault,\r\n      uint256 _posId,\r\n      address _worker,\r\n      uint256 _principalAmount,\r\n      uint256 _borrowAmount,\r\n      uint256 _maxReturn,\r\n      bytes memory _workData\r\n    ) = abi.decode(_data, (address, uint256, address, uint256, uint256, uint256, bytes));\r\n\r\n    // OPENING for initializing positions\r\n    if (\r\n      OPENING != 1 &&\r\n      !((_vault == stableVault && _posId == stableVaultPosId) || (_vault == assetVault && _posId == assetVaultPosId))\r\n    ) {\r\n      revert DeltaNeutralVault_InvalidPositions({ _vault: _vault, _positionId: _posId });\r\n    }\r\n\r\n    // 2. approve vault\r\n    IERC20Upgradeable(stableToken).safeApprove(_vault, type(uint256).max);\r\n    IERC20Upgradeable(assetToken).safeApprove(_vault, type(uint256).max);\r\n\r\n    // 3. Call work to altering Vault position\r\n    IVault(_vault).work(_posId, _worker, _principalAmount, _borrowAmount, _maxReturn, _workData);\r\n\r\n    // 4. Reset approve to 0\r\n    IERC20Upgradeable(stableToken).safeApprove(_vault, 0);\r\n    IERC20Upgradeable(assetToken).safeApprove(_vault, 0);\r\n  }\r\n\r\n  /// @dev _getTokenPrice with validate last price updated\r\n  function _getTokenPrice(address _token) internal view returns (uint256) {\r\n    (uint256 _price, uint256 _lastUpdated) = priceOracle.getTokenPrice(_token);\r\n    // _lastUpdated > 1 day revert\r\n    if (block.timestamp - _lastUpdated > 86400) revert DeltaNeutralVault_UnTrustedPrice();\r\n    return _price;\r\n  }\r\n\r\n  /// @notice Calculate share from value and total equity\r\n  /// @param _value Value to convert\r\n  /// @param _totalEquity Total equity at the time of calculation\r\n  function _valueToShare(uint256 _value, uint256 _totalEquity) internal view returns (uint256) {\r\n    uint256 _shareSupply = totalSupply() + pendingManagementFee();\r\n    if (_shareSupply == 0) return _value;\r\n    return FullMath.mulDiv(_value, _shareSupply, _totalEquity);\r\n  }\r\n\r\n  /// @dev Return a conversion factor to 18 decimals.\r\n  /// @param _token token to convert.\r\n  function _to18ConversionFactor(address _token) internal view returns (uint256) {\r\n    uint256 _decimals = ERC20Upgradeable(_token).decimals();\r\n    if (_decimals > 18) revert DeltaNeutralVault_UnsupportedDecimals(_decimals);\r\n    if (_decimals == 18) return 1;\r\n    uint256 _conversionFactor = 10**(18 - _decimals);\r\n    return _conversionFactor;\r\n  }\r\n\r\n  /// @dev Fallback function to accept BNB.\r\n  receive() external payable {}\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IDeltaNeutralOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface IDeltaNeutralOracle {\r\n  /// @dev Return value in USD for the given lpAmount.\r\n  function lpToDollar(uint256 _lpAmount, address _pancakeLPToken) external view returns (uint256, uint256);\r\n\r\n  /// @dev Return amount of LP for the given USD.\r\n  function dollarToLp(uint256 _dollarAmount, address _lpToken) external view returns (uint256, uint256);\r\n\r\n  /// @dev Return value of given token in USD.\r\n  function getTokenPrice(address _token) external view returns (uint256, uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\nabstract contract IVault {\r\n  struct Position {\r\n    address worker;\r\n    address owner;\r\n    uint256 debtShare;\r\n  }\r\n\r\n  mapping(uint256 => Position) public positions;\r\n\r\n  //@dev Return address of the token to be deposited in vault\r\n  function token() external view virtual returns (address);\r\n\r\n  uint256 public vaultDebtShare;\r\n\r\n  uint256 public vaultDebtVal;\r\n\r\n  //@dev Return next position id of vault\r\n  function nextPositionID() external view virtual returns (uint256);\r\n\r\n  //@dev Return the pending interest that will be accrued in the next call.\r\n  function pendingInterest(uint256 value) external view virtual returns (uint256);\r\n\r\n  function fairLaunchPoolId() external view virtual returns (uint256);\r\n\r\n  /// @dev a function for interacting with position\r\n  function work(\r\n    uint256 id,\r\n    address worker,\r\n    uint256 principalAmount,\r\n    uint256 borrowAmount,\r\n    uint256 maxReturn,\r\n    bytes calldata data\r\n  ) external payable virtual;\r\n}\r\n"
    },
    "contracts/interfaces/IWorker02.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\nimport \"./IWorker.sol\";\r\n\r\ninterface IWorker02 is IWorker {\r\n  /// @dev Return the trading path that worker is using for convert BTOKEN->...->FTOKEN\r\n  function getPath() external view returns (address[] memory);\r\n\r\n  /// @dev Return the inverse of the path that worker is using for convert BTOKEN->...->FTOKEN\r\n  function getReversedPath() external view returns (address[] memory);\r\n\r\n  /// @dev Return the trading path that the worker is using to convert reward token to beneficial vault token\r\n  function getRewardPath() external view returns (address[] memory);\r\n\r\n  /// @dev Return the amount of lp that worker has\r\n  function totalLpBalance() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface IWETH {\r\n  function deposit() external payable;\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function withdraw(uint256) external;\r\n}\r\n"
    },
    "contracts/interfaces/IWNativeRelayer.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface IWNativeRelayer {\r\n  function withdraw(uint256 _amount) external;\r\n}\r\n"
    },
    "contracts/interfaces/IFairLaunch.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface IFairLaunch {\r\n  function poolLength() external view returns (uint256);\r\n\r\n  function addPool(\r\n    uint256 _allocPoint,\r\n    address _stakeToken,\r\n    bool _withUpdate\r\n  ) external;\r\n\r\n  function setPool(\r\n    uint256 _pid,\r\n    uint256 _allocPoint,\r\n    bool _withUpdate\r\n  ) external;\r\n\r\n  function pendingAlpaca(uint256 _pid, address _user) external view returns (uint256);\r\n\r\n  function updatePool(uint256 _pid) external;\r\n\r\n  function deposit(\r\n    address _for,\r\n    uint256 _pid,\r\n    uint256 _amount\r\n  ) external;\r\n\r\n  function withdraw(\r\n    address _for,\r\n    uint256 _pid,\r\n    uint256 _amount\r\n  ) external;\r\n\r\n  function withdrawAll(address _for, uint256 _pid) external;\r\n\r\n  function harvest(uint256 _pid) external;\r\n\r\n  function getFairLaunchPoolId() external returns (uint256);\r\n\r\n  function poolInfo(uint256 _pid)\r\n    external\r\n    returns (\r\n      address,\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    );\r\n}\r\n"
    },
    "contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface ISwapRouter {\r\n  function WETH() external pure returns (address);\r\n\r\n  function swapExactTokensForETH(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapExactETHForTokens(\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  function swapExactTokensForTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapTokensForExactTokens(\r\n    uint256 amountOut,\r\n    uint256 amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function getAmountsIn(uint256 amountOut, address[] memory path) external view returns (uint256[] memory amounts);\r\n\r\n  function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint256[] memory amounts);\r\n}\r\n"
    },
    "contracts/utils/SafeToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface ERC20Interface {\r\n  function balanceOf(address user) external view returns (uint256);\r\n}\r\n\r\nlibrary SafeToken {\r\n  function myBalance(address token) internal view returns (uint256) {\r\n    return ERC20Interface(token).balanceOf(address(this));\r\n  }\r\n\r\n  function safeTransfer(\r\n    address token,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    require(token.code.length > 0, \"!contract\");\r\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \"!safeTransfer\");\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    address token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    require(token.code.length > 0, \"!not contract\");\r\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \"!safeTransferFrom\");\r\n  }\r\n\r\n  function safeApprove(\r\n    address token,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n    require(token.code.length > 0, \"!not contract\");\r\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n    require(success && (data.length == 0 || abi.decode(data, (bool))), \"!safeApprove\");\r\n  }\r\n\r\n  function safeTransferETH(address to, uint256 value) internal {\r\n    // solhint-disable-next-line no-call-value\r\n    (bool success, ) = to.call{ value: value }(new bytes(0));\r\n    require(success, \"!safeTransferETH\");\r\n  }\r\n}\r\n"
    },
    "contracts/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Arithmetic library with operations for fixed-point numbers.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\r\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\r\nlibrary FixedPointMathLib {\r\n  /*///////////////////////////////////////////////////////////////\r\n                    SIMPLIFIED FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n  uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\r\n\r\n  function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n    return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\r\n  }\r\n\r\n  function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n    return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\r\n  }\r\n\r\n  function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n    return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\r\n  }\r\n\r\n  function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n    return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\r\n  }\r\n\r\n  /*///////////////////////////////////////////////////////////////\r\n                    LOW LEVEL FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n  function mulDivDown(\r\n    uint256 x,\r\n    uint256 y,\r\n    uint256 denominator\r\n  ) internal pure returns (uint256 z) {\r\n    assembly {\r\n      // Store x * y in z for now.\r\n      z := mul(x, y)\r\n\r\n      // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\r\n      if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\r\n        revert(0, 0)\r\n      }\r\n\r\n      // Divide z by the denominator.\r\n      z := div(z, denominator)\r\n    }\r\n  }\r\n\r\n  function mulDivUp(\r\n    uint256 x,\r\n    uint256 y,\r\n    uint256 denominator\r\n  ) internal pure returns (uint256 z) {\r\n    assembly {\r\n      // Store x * y in z for now.\r\n      z := mul(x, y)\r\n\r\n      // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\r\n      if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\r\n        revert(0, 0)\r\n      }\r\n\r\n      // First, divide z - 1 by the denominator and add 1.\r\n      // Then multiply it by 0 if z is zero, or 1 otherwise.\r\n      z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\r\n    }\r\n  }\r\n\r\n  function rpow(\r\n    uint256 x,\r\n    uint256 n,\r\n    uint256 denominator\r\n  ) internal pure returns (uint256 z) {\r\n    assembly {\r\n      switch x\r\n      case 0 {\r\n        switch n\r\n        case 0 {\r\n          // 0 ** 0 = 1\r\n          z := denominator\r\n        }\r\n        default {\r\n          // 0 ** n = 0\r\n          z := 0\r\n        }\r\n      }\r\n      default {\r\n        switch mod(n, 2)\r\n        case 0 {\r\n          // If n is even, store denominator in z for now.\r\n          z := denominator\r\n        }\r\n        default {\r\n          // If n is odd, store x in z for now.\r\n          z := x\r\n        }\r\n\r\n        // Shifting right by 1 is like dividing by 2.\r\n        let half := shr(1, denominator)\r\n\r\n        for {\r\n          // Shift n right by 1 before looping to halve it.\r\n          n := shr(1, n)\r\n        } n {\r\n          // Shift n right by 1 each iteration to halve it.\r\n          n := shr(1, n)\r\n        } {\r\n          // Revert immediately if x ** 2 would overflow.\r\n          // Equivalent to iszero(eq(div(xx, x), x)) here.\r\n          if shr(128, x) {\r\n            revert(0, 0)\r\n          }\r\n\r\n          // Store x squared.\r\n          let xx := mul(x, x)\r\n\r\n          // Round to the nearest number.\r\n          let xxRound := add(xx, half)\r\n\r\n          // Revert if xx + half overflowed.\r\n          if lt(xxRound, xx) {\r\n            revert(0, 0)\r\n          }\r\n\r\n          // Set x to scaled xxRound.\r\n          x := div(xxRound, denominator)\r\n\r\n          // If n is even:\r\n          if mod(n, 2) {\r\n            // Compute z * x.\r\n            let zx := mul(z, x)\r\n\r\n            // If z * x overflowed:\r\n            if iszero(eq(div(zx, x), z)) {\r\n              // Revert if x is non-zero.\r\n              if iszero(iszero(x)) {\r\n                revert(0, 0)\r\n              }\r\n            }\r\n\r\n            // Round to the nearest number.\r\n            let zxRound := add(zx, half)\r\n\r\n            // Revert if zx + half overflowed.\r\n            if lt(zxRound, zx) {\r\n              revert(0, 0)\r\n            }\r\n\r\n            // Return properly scaled zxRound.\r\n            z := div(zxRound, denominator)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /*///////////////////////////////////////////////////////////////\r\n                        GENERAL NUMBER UTILITIES\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n  function sqrt(uint256 x) internal pure returns (uint256 z) {\r\n    assembly {\r\n      // Start off with z at 1.\r\n      z := 1\r\n\r\n      // Used below to help find a nearby power of 2.\r\n      let y := x\r\n\r\n      // Find the lowest power of 2 that is at least sqrt(x).\r\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\r\n        y := shr(128, y) // Like dividing by 2 ** 128.\r\n        z := shl(64, z)\r\n      }\r\n      if iszero(lt(y, 0x10000000000000000)) {\r\n        y := shr(64, y) // Like dividing by 2 ** 64.\r\n        z := shl(32, z)\r\n      }\r\n      if iszero(lt(y, 0x100000000)) {\r\n        y := shr(32, y) // Like dividing by 2 ** 32.\r\n        z := shl(16, z)\r\n      }\r\n      if iszero(lt(y, 0x10000)) {\r\n        y := shr(16, y) // Like dividing by 2 ** 16.\r\n        z := shl(8, z)\r\n      }\r\n      if iszero(lt(y, 0x100)) {\r\n        y := shr(8, y) // Like dividing by 2 ** 8.\r\n        z := shl(4, z)\r\n      }\r\n      if iszero(lt(y, 0x10)) {\r\n        y := shr(4, y) // Like dividing by 2 ** 4.\r\n        z := shl(2, z)\r\n      }\r\n      if iszero(lt(y, 0x8)) {\r\n        // Equivalent to 2 ** z.\r\n        z := shl(1, z)\r\n      }\r\n\r\n      // Shifting right by 1 is like dividing by 2.\r\n      z := shr(1, add(z, div(x, z)))\r\n      z := shr(1, add(z, div(x, z)))\r\n      z := shr(1, add(z, div(x, z)))\r\n      z := shr(1, add(z, div(x, z)))\r\n      z := shr(1, add(z, div(x, z)))\r\n      z := shr(1, add(z, div(x, z)))\r\n      z := shr(1, add(z, div(x, z)))\r\n\r\n      // Compute a rounded down version of z.\r\n      let zRoundDown := div(x, z)\r\n\r\n      // If zRoundDown is smaller, use it.\r\n      if lt(zRoundDown, z) {\r\n        z := zRoundDown\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/utils/Math.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\nlibrary Math {\r\n  /**\r\n   * @dev Check if two values are almost equal within toleranceBps.\r\n   */\r\n  function almostEqual(\r\n    uint256 value0,\r\n    uint256 value1,\r\n    uint256 toleranceBps\r\n  ) internal pure returns (bool) {\r\n    uint256 maxValue = max(value0, value1);\r\n    return ((maxValue - min(value0, value1)) * 10000) <= toleranceBps * maxValue;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the largest of two numbers.\r\n   */\r\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the smallest of two numbers.\r\n   */\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the rounded number.\r\n   */\r\n  function e36round(uint256 a) internal pure returns (uint256) {\r\n    return (a + 5e17) / 1e18;\r\n  }\r\n}\r\n"
    },
    "contracts/utils/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\n/// @title Contains 512-bit math functions\r\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\r\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\r\nlibrary FullMath {\r\n  /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n  /// @param a The multiplicand\r\n  /// @param b The multiplier\r\n  /// @param denominator The divisor\r\n  /// @return result The 256-bit result\r\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\n  function mulDiv(\r\n    uint256 a,\r\n    uint256 b,\r\n    uint256 denominator\r\n  ) internal pure returns (uint256 result) {\r\n    unchecked {\r\n      // 512-bit multiply [prod1 prod0] = a * b\r\n      // Compute the product mod 2**256 and mod 2**256 - 1\r\n      // then use the Chinese Remainder Theorem to reconstruct\r\n      // the 512 bit result. The result is stored in two 256\r\n      // variables such that product = prod1 * 2**256 + prod0\r\n      uint256 prod0; // Least significant 256 bits of the product\r\n      uint256 prod1; // Most significant 256 bits of the product\r\n      assembly {\r\n        let mm := mulmod(a, b, not(0))\r\n        prod0 := mul(a, b)\r\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n      }\r\n\r\n      // Handle non-overflow cases, 256 by 256 division\r\n      if (prod1 == 0) {\r\n        require(denominator > 0);\r\n        assembly {\r\n          result := div(prod0, denominator)\r\n        }\r\n        return result;\r\n      }\r\n\r\n      // Make sure the result is less than 2**256.\r\n      // Also prevents denominator == 0\r\n      require(denominator > prod1);\r\n\r\n      ///////////////////////////////////////////////\r\n      // 512 by 256 division.\r\n      ///////////////////////////////////////////////\r\n\r\n      // Make division exact by subtracting the remainder from [prod1 prod0]\r\n      // Compute remainder using mulmod\r\n      uint256 remainder;\r\n      assembly {\r\n        remainder := mulmod(a, b, denominator)\r\n      }\r\n      // Subtract 256 bit number from 512 bit number\r\n      assembly {\r\n        prod1 := sub(prod1, gt(remainder, prod0))\r\n        prod0 := sub(prod0, remainder)\r\n      }\r\n\r\n      // Factor powers of two out of denominator\r\n      // Compute largest power of two divisor of denominator.\r\n      // Always >= 1.\r\n      uint256 twos = (type(uint256).max - denominator + 1) & denominator;\r\n      // Divide denominator by power of two\r\n      assembly {\r\n        denominator := div(denominator, twos)\r\n      }\r\n\r\n      // Divide [prod1 prod0] by the factors of two\r\n      assembly {\r\n        prod0 := div(prod0, twos)\r\n      }\r\n      // Shift in bits from prod1 into prod0. For this we need\r\n      // to flip `twos` such that it is 2**256 / twos.\r\n      // If twos is zero, then it becomes one\r\n      assembly {\r\n        twos := add(div(sub(0, twos), twos), 1)\r\n      }\r\n      prod0 |= prod1 * twos;\r\n\r\n      // Invert denominator mod 2**256\r\n      // Now that denominator is an odd number, it has an inverse\r\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n      // Compute the inverse by starting with a seed that is correct\r\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n      uint256 inv = (3 * denominator) ^ 2;\r\n      // Now use Newton-Raphson iteration to improve the precision.\r\n      // Thanks to Hensel's lifting lemma, this also works in modular\r\n      // arithmetic, doubling the correct bits in each step.\r\n      inv *= 2 - denominator * inv; // inverse mod 2**8\r\n      inv *= 2 - denominator * inv; // inverse mod 2**16\r\n      inv *= 2 - denominator * inv; // inverse mod 2**32\r\n      inv *= 2 - denominator * inv; // inverse mod 2**64\r\n      inv *= 2 - denominator * inv; // inverse mod 2**128\r\n      inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n      // Because the division is now exact we can divide by multiplying\r\n      // with the modular inverse of denominator. This will give us the\r\n      // correct result modulo 2**256. Since the precoditions guarantee\r\n      // that the outcome is less than 2**256, this is the final result.\r\n      // We don't need to compute the high bits of the result and prod1\r\n      // is no longer required.\r\n      result = prod0 * inv;\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n  /// @param a The multiplicand\r\n  /// @param b The multiplier\r\n  /// @param denominator The divisor\r\n  /// @return result The 256-bit result\r\n  function mulDivRoundingUp(\r\n    uint256 a,\r\n    uint256 b,\r\n    uint256 denominator\r\n  ) internal pure returns (uint256 result) {\r\n    result = mulDiv(a, b, denominator);\r\n    unchecked {\r\n      if (mulmod(a, b, denominator) > 0) {\r\n        require(result < type(uint256).max);\r\n        result++;\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IWorker.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\nimport \"./IPancakePair.sol\";\r\n\r\ninterface IWorker {\r\n  /// @dev Work on a (potentially new) position. Optionally send token back to Vault.\r\n  function work(\r\n    uint256 id,\r\n    address user,\r\n    uint256 debt,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  /// @dev Re-invest whatever the worker is working on.\r\n  function reinvest() external;\r\n\r\n  /// @dev Return the amount of wei to get back if we are to liquidate the position.\r\n  function health(uint256 id) external view returns (uint256);\r\n\r\n  /// @dev Liquidate the given position to token. Send all token back to its Vault.\r\n  function liquidate(uint256 id) external;\r\n\r\n  /// @dev SetStretegy that be able to executed by the worker.\r\n  function setStrategyOk(address[] calldata strats, bool isOk) external;\r\n\r\n  /// @dev Set address that can be reinvest\r\n  function setReinvestorOk(address[] calldata reinvestor, bool isOk) external;\r\n\r\n  /// @dev LP token holds by worker\r\n  function lpToken() external view returns (address);\r\n\r\n  /// @dev Base Token that worker is working on\r\n  function baseToken() external view returns (address);\r\n\r\n  /// @dev Farming Token that worker is working on\r\n  function farmingToken() external view returns (address);\r\n}\r\n"
    },
    "contracts/interfaces/IPancakePair.sol": {
      "content": "// SPDX-License-Identifier: BUSL\r\n/**\r\n  ∩~~~~∩ \r\n  ξ ･×･ ξ \r\n  ξ　~　ξ \r\n  ξ　　 ξ \r\n  ξ　　 “~～~～〇 \r\n  ξ　　　　　　 ξ \r\n  ξ ξ ξ~～~ξ ξ ξ \r\n　 ξ_ξξ_ξ　ξ_ξξ_ξ\r\nAlpaca Fin Corporation\r\n*/\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface IPancakePair {\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  function name() external pure returns (string memory);\r\n\r\n  function symbol() external pure returns (string memory);\r\n\r\n  function decimals() external pure returns (uint8);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address owner) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) external returns (bool);\r\n\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n  function nonces(address owner) external view returns (uint256);\r\n\r\n  function permit(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    uint256 deadline,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n\r\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n  event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n  event Swap(\r\n    address indexed sender,\r\n    uint256 amount0In,\r\n    uint256 amount1In,\r\n    uint256 amount0Out,\r\n    uint256 amount1Out,\r\n    address indexed to\r\n  );\r\n  event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n  function factory() external view returns (address);\r\n\r\n  function token0() external view returns (address);\r\n\r\n  function token1() external view returns (address);\r\n\r\n  function getReserves()\r\n    external\r\n    view\r\n    returns (\r\n      uint112 reserve0,\r\n      uint112 reserve1,\r\n      uint32 blockTimestampLast\r\n    );\r\n\r\n  function price0CumulativeLast() external view returns (uint256);\r\n\r\n  function price1CumulativeLast() external view returns (uint256);\r\n\r\n  function kLast() external view returns (uint256);\r\n\r\n  function mint(address to) external returns (uint256 liquidity);\r\n\r\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\r\n\r\n  function swap(\r\n    uint256 amount0Out,\r\n    uint256 amount1Out,\r\n    address to,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  function skim(address to) external;\r\n\r\n  function sync() external;\r\n\r\n  function initialize(address, address) external;\r\n}\r\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}